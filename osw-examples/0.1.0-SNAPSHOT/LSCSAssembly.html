<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="docs">
<meta name="generator" content="Paradox, paradox-material-theme=0.7.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="docs">
<link rel="shortcut icon" href="assets/images/favicon.png">
<title>LSCS Segments Assembly Â· Lower Segment Control System Demonstration</title>
<link rel="stylesheet" href="assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="lib/prettify/prettify.css">
<script src="assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="assets/fonts/font-awesome.css">
<link rel="stylesheet" href="assets/fonts/material-icons.css">
<link rel="stylesheet" href="assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="index.html" title="Lower Segment Control System Demonstration" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Lower Segment Control System Demonstration
</span>
<span class="md-header-nav__topic">
LSCS Segments Assembly
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="index.html" title="Lower Segment Control System Demonstration" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="index.html" title="Lower Segment Control System Demonstration">
Lower Segment Control System Demonstration
</a>
</label>
<ul>
  <li><a href="input-output.html" class="page">Setup Input/Output</a></li>
  <li><a href="LSCSAssembly.html" class="active page">LSCS Segments Assembly</a></li>
  <li><a href="LSCSHcd.html" class="page">LSCS Segments HCD</a></li>
  <li><a href="LSCSSimulator.html" class="page">LSCS Simulator and JPL Simulator</a></li>
  <li><a href="Deploy.html" class="page">Segments Assembly and HCD Deployment</a></li>
  <li><a href="TestingAndShell.html" class="page">Testing LSCS Code and Using esw-shell</a></li>
  <li><a href="Goals.html" class="page">Goals Summary</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="LSCSAssembly.html#lscs-segments-assembly" class="header">LSCS Segments Assembly</a>
  <ul>
    <li><a href="LSCSAssembly.html#top-level-actor" class="header">Top Level Actor</a></li>
    <li><a href="LSCSAssembly.html#assembly-command-validation" class="header">Assembly Command Validation</a></li>
    <li><a href="LSCSAssembly.html#assembly-command-execution" class="header">Assembly Command Execution</a></li>
    <li><a href="LSCSAssembly.html#tracking-the-hcd-and-creation-of-command-service" class="header">Tracking the HCD and Creation of Command Service</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.1.0*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="LSCSAssembly.html#lscs-segments-assembly" class="header">LSCS Segments Assembly</a>
  <ul>
    <li><a href="LSCSAssembly.html#top-level-actor" class="header">Top Level Actor</a></li>
    <li><a href="LSCSAssembly.html#assembly-command-validation" class="header">Assembly Command Validation</a></li>
    <li><a href="LSCSAssembly.html#assembly-command-execution" class="header">Assembly Command Execution</a></li>
    <li><a href="LSCSAssembly.html#tracking-the-hcd-and-creation-of-command-service" class="header">Tracking the HCD and Creation of Command Service</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#lscs-segments-assembly" name="lscs-segments-assembly" class="anchor"><span class="anchor-link"></span></a>LSCS Segments Assembly</h1>
<p>The project includes a simplified Segments Assembly. As discussed in the <a href="index.html">overview</a>, the Segments Assembly job is to receive Assembly Setups, convert them to HCD Setups, and forward them to the Segments HCD. There are no events produced by the Assembly and no Setup commands that are handled within the Assembly itself.</p>
<h2><a href="#top-level-actor" name="top-level-actor" class="anchor"><span class="anchor-link"></span></a>Top Level Actor</h2>
<p>The Top Level Actor for Segments Assembly can be found in the <code>lscsComps</code> project in the file named <code>SegmentsAssemblyHandlers.scala</code>, which contains the entire Assembly. As with all CSW Assemblies, the TLA for Segments Assembly implements handlers as needed. In this Assembly, only the <code>validateCommand</code> and <code>onSubmit</code> handlers are implemented. </p>
<h2><a href="#assembly-command-validation" name="assembly-command-validation" class="anchor"><span class="anchor-link"></span></a>Assembly Command Validation</h2>
<p>The <code>validateCommand</code> handler is shown below.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/tmtsoftware.github.io.git/tree/master/lscsComps/src/main/scala/m1cs/segments/assembly/SegmentsAssemblyHandlers.scala#L79-L105" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/**
 * This is the validate handler. This should perform all validation needed so that
 * the command can execute, or it should return a validation error.
 * Here we return an error for an Observe or pass to the Setup validation.
 * @param runId command runId
 * @param controlCommand either a Setup or Observe
 * @return a [ValidateCommandResponse]
 */
override def validateCommand(runId: Id, controlCommand: ControlCommand): ValidateCommandResponse = {
  controlCommand match {
    case setup: Setup =&gt; handleValidation(runId, setup)
    case observe      =&gt; Invalid(runId, UnsupportedCommandIssue(s&quot;$observe command not supported.&quot;))
  }
}

// All Setup validation is performed here
private def handleValidation(runId: Id, setup: Setup): ValidateCommandResponse = {
  if (Common.ALL_COMMANDS.contains(setup.commandName) || setup.commandName.equals(HcdShutdown.shutdownCommand)) {
    Accepted(runId)
  }
  else {
    Invalid(
      runId,
      CommandIssue.UnsupportedCommandIssue(s&quot;Segment Assembly does not support the `${setup.commandName}` command.&quot;)
    )
  }
}</code></pre></dd>
</dl>
<p>The <code>validateCommand</code> checks that the command is a <code>Setup</code> and returns an error if an <code>Observe</code> is received; otherwise it passes on validation of the Setup to <code>handleValidation</code>. Remember that each Setup from the outside has a Setup with the command name equal to the name of the segment command. Therefore, the validation code looks up the command name in the list of implemented commands in Common. This code is shown below:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/tmtsoftware.github.io.git/tree/master/lscsCommands/src/main/scala/m1cs/segments/segcommands/Common.scala#L44-L63" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/**
 * This map is used by the Assembly to access the correct toCommand for an incoming command Setup
 * It maps command name to a function that returns the formatted command
 */
val CommandMap: Map[CommandName, Setup =&gt; String] = Map(
  ACTUATOR.COMMAND_NAME          -&gt; ACTUATOR.toCommand,
  TARG_GEN_ACT.COMMAND_NAME      -&gt; TARG_GEN_ACT.toCommand,
  CFG_CUR_LOOP.COMMAND_NAME      -&gt; CFG_CUR_LOOP.toCommand,
  CFG_ACT_VC.COMMAND_NAME        -&gt; CFG_ACT_VC.toCommand,
  CFG_ACT_OFFLD.COMMAND_NAME     -&gt; CFG_ACT_OFFLD.toCommand,
  CFG_ACT_SNUB.COMMAND_NAME      -&gt; CFG_ACT_SNUB.toCommand,
  SET_LIMIT_ACT.COMMAND_NAME     -&gt; SET_LIMIT_ACT.toCommand,
  SET_PARAM_ACT.COMMAND_NAME     -&gt; SET_PARAM_ACT.toCommand,
  CAL_WH_DEADBANDWH.COMMAND_NAME -&gt; CAL_WH_DEADBANDWH.toCommand,
  MOVE_WH.COMMAND_NAME           -&gt; MOVE_WH.toCommand
)

// This is used by validation of Assembly and HCD to verify that the received command is currently supported. Could
// be removed when all commands are supported
val ALL_COMMANDS: List[CommandName] = CommandMap.keys.toList</code></pre></dd>
</dl>
<p>If the command name is not present, validation fails with an UnsupportedCommandIssue. Otherwise, the command is Accepted. Validation could be improved, but we assume that if the command name is within our list, then the Setup contains all the correct parameters. An error is returned during execution if the handling fails.</p>
<h2><a href="#assembly-command-execution" name="assembly-command-execution" class="anchor"><span class="anchor-link"></span></a>Assembly Command Execution</h2>
<p>Once validated, the <code>onSubmit</code> handler is called. The submit-related code for the Segments Assembly is shown below:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/tmtsoftware.github.io.git/tree/master/lscsComps/src/main/scala/m1cs/segments/assembly/SegmentsAssemblyHandlers.scala#L109-L171" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/**
 * The Assembly receives a Setup command with the name of the low-level command.
 * It transforms it into an HCD command, which is just the String command to all or one segment.
 * Ranges aren&#39;t yet supported.
 */
override def onSubmit(runId: Id, controlCommand: ControlCommand): SubmitResponse = {
  controlCommand match {
    case setup: Setup =&gt; handleSetup(runId, setup)
    case observe      =&gt; Invalid(runId, UnsupportedCommandIssue(s&quot;$observe command not supported.&quot;))
  }
}

/**
 * Processes commands as Setups
 * @param runId command runId
 * @param assemblySetup the [[Setup]] to execute
 * @return [[SubmitResponse]] response from the command. All commands are started currently.
 */
private def handleSetup(runId: Id, assemblySetup: Setup): SubmitResponse = {
  assemblySetup.commandName match {
    case HcdShutdown.shutdownCommand =&gt;
      log.debug(s&quot;Segments Assembly received shutdown request: $runId and $assemblySetup&quot;)
      val hcdSetup = Setup(assemblyPrefix, HcdShutdown.shutdownCommand)

      submitAndWaitHCD(runId, hcdSetup) map { sr =&gt;
        cswCtx.commandResponseManager.updateCommand(sr.withRunId(runId))
      }
      Started(runId)
    case cmd =&gt;
      log.info(s&quot;Segments Assembly received a command: &#39;$cmd&#39;,  runId: $runId, setup: $assemblySetup&quot;)

      // This simulates what the Assembly does to send to HCD - has received above Setup
      try {
        val hcdSetup: Setup = HcdDirectCommand.toHcdDirectCommand(assemblyPrefix, assemblySetup)
        // Assembly sends the Setup and updates
        submitAndWaitHCD(runId, hcdSetup) map { sr =&gt;
          log.info(s&quot;Assembly command completed from HCD: $sr&quot;)
          cswCtx.commandResponseManager.updateCommand(sr.withRunId(runId))
        }
        Started(runId)
      }
      catch {
        case _: Exception =&gt;
          CommandResponse.Error(runId, s&quot;An exception was thrown while processing setup: ${assemblySetup.commandName}&quot;)
      }
  }
}

/**
 * This is a convenience routine to check the availability of HCD prior to sending
 * @param runId command runId
 * @param setup the Setup to send
 * @return command response as a SubmitResponse
 */
private def submitAndWaitHCD(runId: Id, setup: Setup): Future[SubmitResponse] =
  hcdCS match {
    case Some(cs) =&gt;
      // Added a delay here because segment commands take an unknown amount of time.
      // Can be made an implicit for all calls in file for a more complex situation with different timeouts.
      cs.submitAndWait(setup)(timeout = 15.seconds)
    case None =&gt;
      Future(CommandResponse.Error(runId, s&quot;The Segment HCD is not currently available: ${hcdConnection.componentId}&quot;))
  }</code></pre></dd>
</dl>
<p>As before, the <code>Observes</code> return an Error (even through we can not get to this code in this example.) The <code>handleSetup</code> command must handle any named commands first. In this case, there is a command called <code>shutdownCommand</code> that when sent to the HCD, it causes all the segment connections to be closed and the HCD shutdown. This is useful for testing.</p>
<p>The second case matches on any other command. In this case, the function <code>HcdDirectCommand.toHcdDirectCommand</code> is called. If it does not fail (it is wrapped in a try clause), a Setup formatted for the HCD is returned and passed to the <code>submitAndWaitHCD</code> function. All this is doing is calling Command Service submitAndWait, but it is checking that the CommandService instance created for the HCD is valid before sending. (This will be covered later.) It also provides a custom timeout, which has been arbitrarily set to 15 seconds for all the segments to complete any command. If this time is exceeded, the submitAndWait will time out and return an error. Note that if the Command Service is not available, because the HCD is not available, an Error is also returned.</p>
<p>The function HcdDirectCommand.toHcdDirectCommand is shown below:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/tmtsoftware.github.io.git/tree/master/lscsComps/src/main/scala/m1cs/segments/shared/HcdCommands.scala#L10-L47" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/**
 * This object contains the parameter keys for the command sent to the HCD to process a single
 * segment command. This is used by the segment Assembly and test code to produce an HCD Setup from
 * an Assembly Setup.
 */
case object HcdDirectCommand {

  val lscsDirectCommand: CommandName = CommandName(&quot;lscsDirectCommand&quot;)
  // This key is used to store the command to be executed
  val lscsCommandKey: Key[String]     = KeyType.StringKey.make(name = &quot;lscsCommand&quot;)
  val lscsCommandNameKey: Key[String] = KeyType.StringKey.make(name = &quot;lscsCommandName&quot;)

  /**
   * This helper function returns a direct command Setup for the
   * @param assemblyPrefix prefix of the Assembly as source
   * @param assemblySetup the Setup received by the Assembly -contains segmentIdKey and command name
   * @param obsId optional ObsId, defaults to None
   * @return Setup ready for sending to HCD
   */
  def toHcdDirectCommand(assemblyPrefix: Prefix, assemblySetup: Setup, obsId: Option[ObsId] = None): Setup = {
    val segmentIdExists    = assemblySetup.exists(segmentIdKey)
    val segmentRangeExists = assemblySetup.exists(segmentRangeKey)
    // Can&#39;t go on without one of these set
    require(segmentIdExists || segmentRangeExists, s&quot;Bad segment info in the Assembly Setup: ${assemblySetup.commandName}&quot;)

    // Convert setup to a String command - note that we know this will work because we validated
    val commandAsString = CommandMap(assemblySetup.commandName)(assemblySetup)

    // Grab the command name from the first part of
    require(commandAsString.nonEmpty, &quot;The command to the HCD must not be empty, fool!&quot;)

    Setup(assemblyPrefix, lscsDirectCommand, obsId).madd(
      lscsCommandKey.set(commandAsString),
      lscsCommandNameKey.set(assemblySetup.commandName.name),
      assemblySetup(segmentIdKey)
    )
  }
}</code></pre></dd>
</dl>
<p>First this function ensures that some required parameters are present in the Setup received by the Assembly. A <code>require</code> will throw an IllegalArgument exception if the condition is false. It then uses the CommandMap structure from Common (shown as part of validation) to extract the <code>toCommand</code> function for the command. This returns the String segment command as discussed in <a href="input-output.html">input</a>. It checks that the command String is not empty.</p>
<p>Then the HCD setup is constructed using parameters from the Assembly Setup and new ones from HcdDirectCommand. The command string is passed with the lscsCommandKey parameter, and the command name is within lscsCommandNameKey. The last entry pulls the segmentIdKey from the Assembly Setup and inserts it into the HCD setup.</p>
<p>The HCD Setup for the Assembly Setup:</p>
<pre class="prettyprint"><code class="language-scala">Setup(paramSet=Set(ACT_ID((1,3)none), MODE((TRACK)none), TARGET((22.34)none), 
  SegmentId((A23)none)), source=M1CS.hcdClient, commandName=CommandName(ACTUATOR), maybeObsId=None)
</code></pre>
<p>is:</p>
<pre class="prettyprint"><code class="language-scala">Setup(paramSet=Set(lscsCommand((ACTUATOR ACT_ID=(1,3), MODE=TRACK, TARGET=22.34)none), 
      lscsCommandName((ACTUATOR)none), SegmentId((ALL)none)), 
      source=M1CS.segmentAssembly, commandName=CommandName(lscsDirectCommand), maybeObsId=None)
</code></pre>
<h3><a href="#handling-submitresponse-from-the-segments-hcd" name="handling-submitresponse-from-the-segments-hcd" class="anchor"><span class="anchor-link"></span></a>Handling SubmitResponse from the Segments HCD</h3>
<p>One last thing is that the Assembly must handle the SubmitResponse from the HCD. When the Assembly sends the HCD Setup to the HCD, a new <code>runId</code> is created for the command. When the command completes, the Assembly needs to pass an appropriate response back to the caller. This is handled by the following piece of code that is repeated fro above:</p>
<pre class="prettyprint"><code class="language-scala">submitAndWaitHCD(runId, hcdSetup) map { sr =&gt;
  cswCtx.commandResponseManager.updateCommand(sr.withRunId(runId))
}
Started(runId)
</code></pre>
<p>The onSubmit handler sends the command using submitAndWaitHCD and then returns <code>Started</code> to the caller. This is a CSW long-running command (as opposed to an immediate-completion command). The HCD command runs asynchronously and returns a value in the future. When that occurs, the result is mapped to the closure shown, which calls the Assembly&rsquo;s Command Response Manager with the SubmitResponse from the HCD, but it replaces the HCD runId with the Assembly Setup&rsquo;s runId using <code>withRunId</code>. That&rsquo;s all that is needed to handle the response from the HCD to the Assembly caller.</p>
<p>That&rsquo;s the extent of the Setup processing in the Assembly.</p>
<h2><a href="#tracking-the-hcd-and-creation-of-command-service" name="tracking-the-hcd-and-creation-of-command-service" class="anchor"><span class="anchor-link"></span></a>Tracking the HCD and Creation of Command Service</h2>
<p>The last bit of interesting code in the SegmentsAssemblyHandlers is how the SegmentsAssembly gets connection information about the Segments HCD, which it must have to send it commands.</p>
<p>As a reminder, connections (i.e. hosts and ports) are not hard-coded in CSW. When a component starts up, its Supervisor registers itself with the Location Service on behalf of the TLA and that location information includes enough information so that one component can create an appropriate connection to the other. CSW supports Akka-based connections and HTTP-based connections.</p>
<p>When the Segments Assembly starts up its Component Configuration File contains an entry that indicates to the Supervisor that it wants to <code>track</code> the HCD. The &ldquo;SegmentsAssemblyStandalone.conf&rdquo; conf file is shown here.</p>
<pre class="prettyprint"><code class="language-scala">prefix = &quot;m1cs.segmentsAssembly&quot;
componentType = assembly
behaviorFactoryClassName = &quot;m1cs.segments.assembly.SegmentsAssemblyBehaviorFactory&quot;
locationServiceUsage = RegisterAndTrackServices
connections = [
  {
    prefix: &quot;m1cs.segmentsHCD&quot;
    componentType: hcd
    connectionType: akka
  }
]
</code></pre>
<p>This file is discussed in the CSW documentation. The key in this discussion is that the <code>connections</code> array has an entry for the an HCD with prefix <code>m1cs.segmentsHCD</code> and connectionType: Akka. This indicates to CSW and the Supervisor of the Assembly that it should track the Segments HCD and deliver events to the Assembly when the Segments HCD is available and also when/if it shuts down or crashes. To receive tracking events, the assembly overrides the <code>onLocationTrackingEvent</code> handler as shown here.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/tmtsoftware.github.io.git/tree/master/lscsComps/src/main/scala/m1cs/segments/assembly/SegmentsAssemblyHandlers.scala#L54-L75" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/**
 * This is overriding tracking events to gain events for Segments HCD. The Assembly should be started
 * with a Component Configuration file that includes tracking and the info for the Segments HCD.
 * This is done in the test files for reference.
 * When the LocationUpdated event is received, a CommandService is created. When the
 * connection goes down, the CommandService is set to None. When None an error is issued in onSubmit.
 * @param trackingEvent CSW TrackingEvent.
 */
override def onLocationTrackingEvent(trackingEvent: TrackingEvent): Unit = {
  log.debug(s&quot;onLocationTrackingEvent called: $trackingEvent&quot;)
  trackingEvent match {
    case LocationUpdated(location) =&gt;
      log.debug(s&quot;Assembly received HCD location: $location&quot;)
      // Should be safe here since we are tracking only Akka location
      val hcdLocation = location.asInstanceOf[AkkaLocation]
      hcdCS = Some(CommandServiceFactory.make(hcdLocation)(ctx.system))
    case LocationRemoved(connection) =&gt;
      if (connection == hcdConnection) {
        hcdCS = None
      }
  }
}</code></pre></dd>
</dl>
<p>This code shows that the Assembly is handling two events: <code>locationUpdated</code> and <code>locationRemoved</code>. The locationUpdated is delivered when the HCD is registered and running. When this happens, the Assembly creates a CommandService instance for the HCD.</p>
<p>In the constructor of the Assembly is the following line:</p>
<pre class="prettyprint"><code class="language-scala">private var hcdCS: Option[CommandService] = None // Initially, there is no CommandService for HCD
</code></pre>
<p>Initially this is set to None, meaning there is no Command Service (i.e. the HCD is not available). When the HCD is available, a CommandService instance is created and this variable is set to its value as shown.</p>
<p>Then, when a command is sent and processed by the <code>submitAndWaitHCD</code> call way up in the Assembly Command Execution section, it checks the value of this Option. If present, the command is sent to the HCD. If None, an Error is returned to the caller.</p>
<p>This is an excellent way to track the availability of an Assembly or HCD using the builtin CSW functionality.</p>
</div>
<div>
<a href="https://github.com/tmtsoftware/tmtsoftware.github.io.git/tree/master/docs/src/main/LSCSAssembly.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.1.0*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="input-output.html" title="Setup Input/Output" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Setup Input/Output
</span>
</div>
</a>
<a href="LSCSHcd.html" title="LSCS Segments HCD" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
LSCS Segments HCD
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="assets/javascripts/application.583bbe55.js"></script>
<script src="assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"."}})</script>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
