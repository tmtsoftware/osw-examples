{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Lower Segment Control System Demonstration"},{"location":"/index.html#lower-segment-control-system-demonstration","text":"This is documentation for the Lower Segment Control System (LSCS) demonstration project that is present in the TMT GitHub site. This project was created to research and demonstrate potential issues around the M1CS subsystem.\nIn the M1CS design, there is a CSW Assembly/HCD that accepts commands that are then passed to one or more mirror segments. Each of the 492 segments includes a Lower Segment Control System, which is running on a specialized processor running compiled C-code. The M1CS group has defined a socket-based protocol for the LSCS, based on a JPL library, that wraps String-based commands.\nThe following figure shows the architecture targeted by this demonstration, which is based on the design of the M1CS group placed within the CSW architecture planned for the telescope site.\nIn this figure a future browser-based M1CS Engineering User Interface issues commands to the LSCS Assembly through the ESW UI Gateway. The commands flow through the UI Gateway to the LSCS Assembly in the form of CSW Setup commands. The commands are passed to the HCD, which understands the LSCS-protocol and has established a TCP-based connection to each of the 492 LSC segment systems. As mentioned, the commands are Strings in the format documented in SegmentHcdCmdDict_20210902.pdf. An example command String is:\nThe protocol is not described here, but involves completion information and updates when the commands take a long time. Interesting requirements of this system is that: 1) Each LSCS can execute more than one command at a time, 2) The commands may complete in a different order than started. 3) A command issued to the LSCS Assembly may be directed to one segment or all of the 492 segments, and 4) The command issued to the Assembly is only complete when the command to all 492 segments have completed. The system is highly asynchronous and non-blocking.\nThe following figure shows what is present in LSCS Demonstration.","title":"Lower Segment Control System Demonstration"},{"location":"/index.html#demonstration-products","text":"The deliverables of this demonstration project include:\nLCSC Assembly LSCS HCD LSCS Simulator Test Code","title":"Demonstration Products"},{"location":"/index.html#issues-addressed-in-the-demonstration","text":"The following issues are addressed:\nThe structure of the M1CS end-to-end system Demonstration of how to create Setups that map to LSCS commands Provide examples of implementing the LSCS commands (not all commands in the dictionary are provided) Support for sending a command to one or all segments in the HCD Support for sending commands to Segment using JPL protocol and communicate with the M1CS-team’s simulator Demonstration that commands to all segments can complete when all segment commands complete Demonstrate that individual segment commands can complete asynchronously Demonstrate that a HCD can handle overlapping asynchronous commands Demonstrate that the CSW HCD can make 492 socket connections to the project-provided LSCS simulator Show how to test the code at various levels Demonstrate how to send commands to the LSCS Assembly from esw-shell","title":"Issues Addressed in the Demonstration"},{"location":"/index.html#description-of-how-things-work","text":"This section describes the overall design of this code and the responsibilities of each component. The previous figure is referenced.","title":"Description of How Things Work"},{"location":"/index.html#segments-assembly","text":"The Segments Assembly is a CSW Assembly that receives commands in the form of CSW Setups. In this demonstration implementation a Setup is constructed for a subset of the commands in the SegmentHcdCmdDict_20210902.pdf document (for more information on the construction of Setup commands, see Setup Input/Output). As shown in the previous figure, these Setups can be constructed in many clients including: a future M1CS Engineering UI, a Sequencer Script, esw-shell, or test code.\nThe job of the Segments Assembly in this case is minimal. It receives an Assembly Setup and creates a Setup for the Segment HCD. It then sends the HCD Setup to the HCD and waits asynchronously for a SubmitResponse. When the SubmitResponse is received from the HCD, it forwards it to the caller.","title":"Segments Assembly"},{"location":"/index.html#segments-hcd","text":"The Segments HCD is the component that keeps track of connections to the segments. It receives HCD Setups, typically from the Segments Assembly, but any client can send a properly formatted HCD Setup to the Segments HCD. In this implementation, there is one command called lscsDirectCommand. An instance of this command contains a formatted LSCS command String converted by the Assembly along with the destination, which can be a single segment, or all segments.\nThe Segments HCD’s only job is to handle these Setups by sending the formatted command to one or all of the configured segments and waiting for completion, which may be successful or an error.\nThe Segments HCD uses an actor called the SegComMonitor to send and wait for responses from the segments. Assuming all segments complete successfully, the monitor sends a CSW Completed SubmitResponse to the caller, which in the operational case is the Segment Assembly. If an Error is received from a Segment, an Error SubmitResponse is returned to the caller.\nWhen Segments HCD starts up, during its initialization, it creates connections to the segments. The external socket connection is made when the segment is created.\nThe number of segments created in each sector can be specified in an application.conf m1cs file block as shown below. Setting m1cs.segments to a number smaller than 82 results in a less than full mirror. Each of the 6 sectors (A-F) always gets the number of segments specified. For instance if m1cs.segments is 2, the segments A1, B1, C1, D1, E1, F1, A2, B2, C2, D2, E2, F2 are created. The following snippet shows the configuration section of application.conf in the testing area.\nm1cs.segments = 20\nBy default, the full mirror is configured with 82 segments in each sector if there is no m1cs.segments config value.\nWarning This configuration value is present because on the macOS it is not possible to create 492 segment connections with the simulator. If you are working on Linux, this value can be set to the maximum value of 82. This is not a limitation on CSW, there is some issue or parameter in macOS that we have not discovered, and since Linux is our target platform, we are not concerned. It is also possible to run the simulator on Linux and the test/client code on macOS.\nNote There is the start of code to allow creation of ranges of sectors. The thought was that segments may be added in unknown patterns. After hearing this was not needed, that feature was stopped, but this code still exists for future use. It would not be too hard to complete this support.","title":"Segments HCD"},{"location":"/index.html#segment-actor","text":"The Segments HCD creates a Segment Actor for each configured Segment. The Segment Actor provides an API to the caller that is simple and largely based on the description of the M1CS protocol (Started, Completed, etc.) Each Segment Actor manages a socket-based connection to a segment. In the demonstration, this is a socket connection to the simulator. The Segment Actor and its segment are addressed through their SegmentId, which is a sector [A-F] followed by a segment number [1-82] or, for example, C32.","title":"Segment Actor"},{"location":"/index.html#lscs-simulator","text":"A JVM-based Simulator has been provided as part of the demonstration. The formatted LSCS command is sent to the simulator, but the simulator does not implement the LSCS commands. For every command, the JVM simulator delays a random amount of time and returns Completed in the JPL protocol.\nThe Segment Actor communicates with the JVM-based Simulator using the JPL protocol as implemented in the C-based library (to the best of our knowledge). This could be improved but for the goals of this demonstration, it is not necessary.\nThe JVM-based Simulator is needed because the M1CS C-based Simulator does not allow demonstration of the goals of this project (at this time). However, if segments is set low enough and the tests are simple enough, the demonstration code works properly with the M1CS Simulator as well. As the M1CS simulator is enhanced it will be possible to use the C-based simulator with the identical code. (It would also be possible to enhance the Scala-based simulator, but using the C-based library is probably a good idea.)\nPlease see the other doc pages for a bit more detail one each of these subjects.","title":"LSCS Simulator"},{"location":"/input-output.html","text":"","title":"Setup Input/Output"},{"location":"/input-output.html#setup-input-output","text":"This section describes how commands are encoded as Setups and how they are unpacked and transformed into commands that go to the individual segments.","title":"Setup Input/Output"},{"location":"/input-output.html#input-setup-description","text":"The Segment Assembly receives CSW Setups, which may come from a variety of sources. In this project we demonstrate Setups from test code and using esw-shell (in a later section on testing). Input describes how Setups are created.\nThe strategy is to build a library of functions that make it relatively easy to construct Setups. The API is based on the previously referenced document. In this document each command is documented with a set of parameters that are required or optional.\nThe set of parameters for each command is generally different, although some share parameters. For instance, many commands include a selection of actuators. Each command also has a common parameter that indicates if the command should go to one specified segment or to all segments.\nThe creation of Setups is implemented in a separate project with only the code needed for the job so that a JAR file can be created that can be loaded into esw-shell. The lscsCommands JAR only depends on CSW libraries, which are included in esw-shell; therefore, scripts can be written using the library functions.","title":"Input: Setup Description"},{"location":"/input-output.html#implementing-commands","text":"A representative subset of the commands have been implemented. The plan was to do them all, but the documentation gets less reliable towards the end and is missing command examples for a few important commands.\nThere is a subproject called lscsCommands. This project contains all the code to create Assembly Setups and to extract and convert an Assembly Setup to a segment command string.\nUnder the package m1cs.segments.segcommands there is a file for each implemented command that is the name of the command. There are currently 10 commands implemented. Examples are: ACTUATOR, CFG_ACT_OFFLD, etc.\nIn each command file there is an object with the same name (i.e. ACTUATOR). An example is the Actuator command shown below, which includes all the features of the command implementation. Within the object is all the code to create a Setup and to extract a segment command. All commands are constructed the same way.\nScala copysourceobject ACTUATOR {\n  import Common.*\n\n  // ACTUATOR command\n  val COMMAND_NAME: CommandName = CommandName(\"ACTUATOR\")\n\n  object ActuatorModes extends Enumeration {\n    type ActuatorMode = Value\n\n    val OFF: Value       = Value(1, \"OFF\")\n    val TRACK: Value     = Value(2, \"TRACK\")\n    val SLEW: Value      = Value(3, \"SLEW\")\n    val CALIBRATE: Value = Value(4, \"CALIBRATE\")\n  }\n\n  import ActuatorModes.*\n\n  val actuatorChoices: Choices    = Choices.from(OFF.toString, TRACK.toString, SLEW.toString, CALIBRATE.toString)\n  val actuatorModeKey: GChoiceKey = ChoiceKey.make(\"MODE\", actuatorChoices)\n  val targetKey: Key[Float]       = KeyType.FloatKey.make(\"TARGET\")\n\n  case class toActuator(prefix: Prefix, actId: Set[Int]) extends BaseCommand[toActuator](prefix, COMMAND_NAME) {\n\n    setup = Common.addActuators(setup, actId)\n\n    def withMode(mode: ActuatorMode): toActuator = {\n      setup = setup.add(actuatorModeKey.set(Choice(mode.toString)))\n      this\n    }\n\n    def withTarget(target: Double): toActuator = {\n      setup = setup.add(targetKey.set(target.toFloat))\n      this\n    }\n\n    // Make a copy -- do any checks here\n    override def asSetup: Setup = {\n      val mode   = setup.get(actuatorModeKey)\n      val target = setup.get(targetKey)\n\n      // Check that there is at least one\n      require(mode.isDefined || target.isDefined, \"Actuator must have either a mode or target or both.\")\n\n      // Should require a segment set\n      Setup(setup.source, setup.commandName, setup.maybeObsId, setup.paramSet)\n    }\n  }\n\n  /**\n   * Returns a formatted ACTUATOR command from a [Setup]\n   *\n   * @param setup Setup created with toActuator\n   * @return String command ready to send\n   */\n  def toCommand(setup: Setup): String = {\n    require(setup.commandName == COMMAND_NAME, s\"The provided Setup is not a: $COMMAND_NAME\")\n    val actId        = setup(actuatorIdKey)\n    val modeExists   = setup.exists(actuatorModeKey)\n    val targetExists = setup.exists(targetKey)\n    require(targetExists || modeExists, \"ACTUATOR requires either a mode or a target or both.\")\n    val actIdVal = if (actId.size == 3) \"ALL\" else valuesToString(actId.values)\n    val sb       = new StringBuilder(s\"${setup.commandName.name} ACT_ID=$actIdVal\")\n    if (modeExists) sb ++= s\", MODE=${setup(actuatorModeKey).head.name}\"\n    if (targetExists) sb ++= s\", TARGET=${setup(targetKey).head}\"\n    sb.result()\n  }\n}\nAt the top of the object common code is imported. Following this is the name of the command, which is again, the name of the file.\nNote In this example, I decided that there would be a unique Setup for each command. So the CommandName is the name of the segment command. An alternative would be to have a single Setup type and include a parameter called CommandName. There are pros/cons of each approach. For the HCD, I selected the second approach.\nNote Each command is implemented as a case class with parameters that are the command’s required parameters. There is a base class for all commands that includes a Setup and support for sending the command to one or all the segments with a segmentId key.\nIn this case, ACTUATOR includes the prefix of the sender, and a Set of integers indicating the actuators to influence. Examples are Set(1), Set(1,3). To indicate all actuators you can say Set(1,2,3) or ALL_ACTUATORS, which is an alias for Set(1,2,3). If the source is prefix: M1CS.client, the minimal Actuator command is:\nval prefix=Prefix(\"M1CS.client\") \ntoActuator(prefix, Set(1))\nThis command is somewhat meaningless, because to be a correct ACTUATOR command it must have at least one of the optional parameters (see below).","title":"Implementing Commands"},{"location":"/input-output.html#optional-parameters","text":"The value returned by toActuator is a toActuator instance. Optional values are added using “with” methods using a fluid-style API so options can be added as needed. For example to add the optional actuator mode and target, the following are all possible:\nval prefix=Prefix(\"M1CS.client\")\n\ntoActuator(prefix, Set(1)).withMode(SLEW)\n\ntoActuator(prefix, Set(1)).withTarget(22.3)\n\ntoActuator(prefix, ALL_ACTUATORS).withMode(SLEW).withTarget(22.3)\nThe case classes include with methods to add optional parameters as in:\ndef withMode(mode: ActuatorMode): toActuator = {\n  setup = setup.add(actuatorModeKey.set(Choice(mode.toString)))\n  this\n}\n\ndef withTarget(target: Double): toActuator = {\n  setup = setup.add(targetKey.set(target.toFloat))\n  this\n}\nEach method returns this, which is in this case an toActuator instance, allowing the fluid style. This is a reasonable way to support optional parameters in a typeable API.","title":"Optional Parameters"},{"location":"/input-output.html#choice-parameters","text":"There are quite a few choice parameters. I’ve implemented them as enumerations as shown below for ActuatorMode:\nobject ActuatorModes extends Enumeration {\n    type ActuatorMode = Value\n\n    val OFF: Value       = Value(1, \"OFF\")\n    val TRACK: Value     = Value(2, \"TRACK\")\n    val SLEW: Value      = Value(3, \"SLEW\")\n    val CALIBRATE: Value = Value(4, \"CALIBRATE\")\n  }\n\n  import ActuatorModes.*\n\nval actuatorChoices: Choices    = Choices.from(OFF.toString, TRACK.toString, SLEW.toString, CALIBRATE.toString)\nval actuatorModeKey: GChoiceKey = ChoiceKey.make(\"MODE\", actuatorChoices)\nval targetKey: Key[Float]       = KeyType.FloatKey.make(\"TARGET\")\nThe values must be imported. This is also true with the API is used externally. Each enumeration is supported with a GChoiceKey and the Choices are made up of the enumeration values as Strings.\nThe last line shows that there is a Float key for the TARGET value. Note that the API takes a Double, not a Float. This is because in Scala (and Java) you must add an f to make a value a Float. The conversion from a Double to a Float is done inside the code to make it a little more friendly to typing.","title":"Choice Parameters"},{"location":"/input-output.html#conversion-to-setup","text":"After creating a command instance like toActutator, it can then be converted to a Setup for submission to the Segment Assembly. Each command includes a method called asSetup that returns a Setup. This is the method that verifies that all the information has been entered that is required.\noverride def asSetup: Setup = {\n  val mode   = setup.get(actuatorModeKey)\n  val target = setup.get(targetKey)\n\n  // Check that there is at least one\n  require(mode.isDefined || target.isDefined, \"Actuator must have either a mode or target or both.\")\n\n  // Should require a segment set\n  Setup(setup.source, setup.commandName, setup.maybeObsId, setup.paramSet)\n}\nIn the ACTUATOR command, when calling asSetup a check is done to verify that at least the mode or target is included. If neither of these parameters is provided, an exception is thrown. If it is good, a copy of the internal Setup is returned.\nWarning Many of the commands in the documentation have optional commands there is no information on what combinations are legal or which ones must really be provided as in the above ACTUATOR case. This can be fixed in the same way as the above was done once the documentation is improved.\nIn summary, to create a Setup to send to the Segment Assembly for the ACTUATOR command, the following is an example:\nval setup = toActuator(prefix, ALL_ACTUATORS).withMode(SLEW).withTarget(22.3).asSetup","title":"Conversion to Setup"},{"location":"/input-output.html#output-converting-a-setup-to-a-segment-command","text":"In the implementation approach mentioned on the overview page, the strategy is that the Assembly Segment receives the assembly Setup and converts it to an HCD Setup. The HCD Setup is a single command that has an argument that is the command that is sent to the segment as a String.\nThe output then is to extract the segment command from the Assembly Setup. Each command also implements a method called toCommand, which uses the parameters of the Setup to create a well-formed command. The following is the toCommand method for the ACTUATOR command.\n/**\n   * Returns a formatted ACTUATOR command from a [Setup]\n   *\n   * @param setup Setup created with toActuator\n   * @return String command ready to send\n   */\n  def toCommand(setup: Setup): String = {\n    require(setup.commandName == COMMAND_NAME, s\"The provided Setup is not a: $COMMAND_NAME\")\n    val actId        = setup(actuatorIdKey)\n    val modeExists   = setup.exists(actuatorModeKey)\n    val targetExists = setup.exists(targetKey)\n    val actIdVal     = if (actId.size == 3) \"ALL\" else valuesToString(actId.values)\n    val sb           = new StringBuilder(s\"${setup.commandName.name} ACT_ID=$actIdVal\")\n    if (modeExists) sb ++= s\", MODE=${setup(actuatorModeKey).head.name}\"\n    if (targetExists) sb ++= s\", TARGET=${setup(targetKey).head}\"\n    sb.result()\n  }\nTo recap, a command includes required parameters and optional parameters. The above shows extracting the values for actuator, which is required. It creates a Boolean to check to see if actuator mode and/or target exists by checking for actuatorModeKey and targetKey.\nThen a StringBuilder is created that creates a String for the command. First, the command is extracted using the Scala String interpolator syntax (${parameter}). The like starting with actIdVal checks to see whether there is a subset or all of the actuators. The valuesToString method formats a proper value for the command (as in (1,2)). Finally, if the mode and target exist, parameters are added to the String for each.\nThe example below is shows the output command that goes with the created Assembly Setup.\nprintln(toCommand(toActuator(prefix, AllActuators).withMode(TRACK).withTarget(22.34).asSetup))\n\nACTUATOR ACT_ID=ALL, MODE=TRACK, TARGET=22.34","title":"Output: Converting a Setup to a Segment Command"},{"location":"/input-output.html#segment-destination","text":"Each command requires a segment location, but the location does not appear in the output command. The Setup contains a parameter for the segment destination. The following is the printed value of an ACTUATOR Setup for the example above.\nprintln(toActuator(prefix, AllActuators).withMode(TRACK).withTarget(22.34).asSetup)\n\nSetup(paramSet=Set(SegmentId((ALL)none), ACT_ID((1,2,3)none), MODE((TRACK)none), TARGET((22.34)none)), \n      source=M1CS.client, commandName=CommandName(ACTUATOR), maybeObsId=None)\nThere is an extra SegmentId parameter with the value ALL, indicating the command will be sent to all segments. This parameter is used by the HCD to do the right thing. The SegmentId parameter is handled within the command base class. By default, a command goes to all segments.\nThe base class also provides two methods called toAll, and toSegment to add a destination to any command as shown here:\nto = toActuator(prefix, Set(1, 3)).withMode(SLEW).toSegment(SegmentId(\"B22\"))\nor\nto = toActuator(prefix, Set(1, 3)).withMode(SLEW).toAll\nA SegmentId instance must be created to send to a specific segment. The SegmentId type verifies that the segment sector is A-F and segment number is 1-82. An exception is thrown if not true.","title":"Segment Destination"},{"location":"/input-output.html#testing-commands","text":"Tests exist for each command to verify that it is working properly. There is one file called SegmentCommandsTests in the lscsCommands test area. Each command has similar tests. The following shows the tests for Actuator.\nScala copysourcetest(\"To From ACTUATOR\") {\n  import m1cs.segments.segcommands.ACTUATOR.*\n  import m1cs.segments.segcommands.ACTUATOR.ActuatorModes.*\n\n  var to = toActuator(prefix, Set(1, 3)).withMode(TRACK)\n  // Verify segmentId is all by default\n  to.asSetup(segmentIdKey).head shouldBe ALL_SEGMENTS\n\n  // Verify override works\n  to = toActuator(prefix, Set(1, 3)).withMode(TRACK).toSegment(SegmentId(\"A22\"))\n  to.asSetup(segmentIdKey).head shouldBe \"A22\"\n\n  // Only 2 actuators\n  to = toActuator(prefix, Set(1, 3)).withMode(TRACK)\n  ACTUATOR.toCommand(to.asSetup) shouldBe s\"${COMMAND_NAME.name} ACT_ID=(1,3), MODE=TRACK\"\n\n  to = toActuator(prefix, Set(1, 3)).withTarget(22.34)\n  ACTUATOR.toCommand(to.asSetup) shouldBe s\"${COMMAND_NAME.name} ACT_ID=(1,3), TARGET=22.34\"\n\n  to = toActuator(prefix, Set(1, 3)).withMode(TRACK).withTarget(target = 22.34)\n  ACTUATOR.toCommand(to.asSetup) shouldBe s\"${COMMAND_NAME.name} ACT_ID=(1,3), MODE=TRACK, TARGET=22.34\"\n\n  // Verify All\n  to = toActuator(prefix, ALL_ACTUATORS).withMode(TRACK).withTarget(22.34)\n  ACTUATOR.toCommand(to.asSetup) shouldBe s\"${COMMAND_NAME.name} ACT_ID=ALL, MODE=TRACK, TARGET=22.34\"\n\n  // Check for no optional\n  assertThrows[IllegalArgumentException] {\n    toActuator(prefix, Set(1, 2, 3)).asSetup\n  }\n\n  // Check for too big set\n  assertThrows[IllegalArgumentException] {\n    toActuator(prefix, Set(1, 2, 3, 4))\n  }\n\n  // Check for empty set\n  assertThrows[IllegalArgumentException] {\n    toActuator(prefix, Set())\n  }\n\n  // Check for out of range ID\n  assertThrows[IllegalArgumentException] {\n    toActuator(prefix, Set(1, 2, 4))\n  }\n}\nThe tests create Setups with varied parameters and test that the output command is correct. Following are tests to verify that exceptions are thrown for bad conditions. For instance, note the test for the lack of an optional parameter.\n// Check for no optional\nassertThrows[IllegalArgumentException] {\n  toActuator(prefix, Set(1, 2, 3)).asSetup\n}\nThis verifies that an exception is thrown if neither withMode nor withTarget is included.","title":"Testing Commands"},{"location":"/input-output.html#input-output-summary","text":"Each command is created in the same way. A file is created in the m1cs.segments.segcommands package with the name of the command. A case class is created for the command with the required parameters. With methods are added for each optional parameter.\nA asSetup method is included to check the Setup for consistency or constraints. A toCommand function is included to use the Setup parameters and output a segment command.","title":"Input/Output Summary"},{"location":"/LSCSAssembly.html","text":"","title":"LSCS Segments Assembly"},{"location":"/LSCSAssembly.html#lscs-segments-assembly","text":"The project includes a simplified Segments Assembly. As discussed in the overview, the Segments Assembly job is to receive Assembly Setups, convert them to HCD Setups, and forward them to the Segments HCD. There are no events produced by the Assembly and no Setup commands that are handled within the Assembly itself.","title":"LSCS Segments Assembly"},{"location":"/LSCSAssembly.html#top-level-actor","text":"The Top Level Actor for Segments Assembly can be found in the lscsComps project in the file named SegmentsAssemblyHandlers.scala, which contains the entire Assembly. As with all CSW Assemblies, the TLA for Segments Assembly implements handlers as needed. In this Assembly, only the validateCommand and onSubmit handlers are implemented.","title":"Top Level Actor"},{"location":"/LSCSAssembly.html#assembly-command-validation","text":"The validateCommand handler is shown below.\nScala copysource/**\n * This is the validate handler. This should perform all validation needed so that\n * the command can execute, or it should return a validation error.\n * Here we return an error for an Observe or pass to the Setup validation.\n * @param runId command runId\n * @param controlCommand either a Setup or Observe\n * @return a [ValidateCommandResponse]\n */\noverride def validateCommand(runId: Id, controlCommand: ControlCommand): ValidateCommandResponse = {\n  controlCommand match {\n    case setup: Setup => handleValidation(runId, setup)\n    case observe      => Invalid(runId, UnsupportedCommandIssue(s\"$observe command not supported.\"))\n  }\n}\n\n// All Setup validation is performed here\nprivate def handleValidation(runId: Id, setup: Setup): ValidateCommandResponse = {\n  if (Common.ALL_COMMANDS.contains(setup.commandName) || setup.commandName.equals(HcdShutdown.shutdownCommand)) {\n    Accepted(runId)\n  }\n  else {\n    Invalid(\n      runId,\n      CommandIssue.UnsupportedCommandIssue(s\"Segment Assembly does not support the `${setup.commandName}` command.\")\n    )\n  }\n}\nThe validateCommand checks that the command is a Setup and returns an error if an Observe is received; otherwise it passes on validation of the Setup to handleValidation. Remember that each Setup from the outside has a Setup with the command name equal to the name of the segment command. Therefore, the validation code looks up the command name in the list of implemented commands in Common. This code is shown below:\nScala copysource/**\n * This map is used by the Assembly to access the correct toCommand for an incoming command Setup\n * It maps command name to a function that returns the formatted command\n */\nval CommandMap: Map[CommandName, Setup => String] = Map(\n  ACTUATOR.COMMAND_NAME          -> ACTUATOR.toCommand,\n  TARG_GEN_ACT.COMMAND_NAME      -> TARG_GEN_ACT.toCommand,\n  CFG_CUR_LOOP.COMMAND_NAME      -> CFG_CUR_LOOP.toCommand,\n  CFG_ACT_VC.COMMAND_NAME        -> CFG_ACT_VC.toCommand,\n  CFG_ACT_OFFLD.COMMAND_NAME     -> CFG_ACT_OFFLD.toCommand,\n  CFG_ACT_SNUB.COMMAND_NAME      -> CFG_ACT_SNUB.toCommand,\n  SET_LIMIT_ACT.COMMAND_NAME     -> SET_LIMIT_ACT.toCommand,\n  SET_PARAM_ACT.COMMAND_NAME     -> SET_PARAM_ACT.toCommand,\n  CAL_WH_DEADBANDWH.COMMAND_NAME -> CAL_WH_DEADBANDWH.toCommand,\n  MOVE_WH.COMMAND_NAME           -> MOVE_WH.toCommand\n)\n\n// This is used by validation of Assembly and HCD to verify that the received command is currently supported. Could\n// be removed when all commands are supported\nval ALL_COMMANDS: List[CommandName] = CommandMap.keys.toList\nIf the command name is not present, validation fails with an UnsupportedCommandIssue. Otherwise, the command is Accepted. Validation could be improved, but we assume that if the command name is within our list, then the Setup contains all the correct parameters. An error is returned during execution if the handling fails.","title":"Assembly Command Validation"},{"location":"/LSCSAssembly.html#assembly-command-execution","text":"Once validated, the onSubmit handler is called. The submit-related code for the Segments Assembly is shown below:\nScala copysource/**\n * The Assembly receives a Setup command with the name of the low-level command.\n * It transforms it into an HCD command, which is just the String command to all or one segment.\n * Ranges aren't yet supported.\n */\noverride def onSubmit(runId: Id, controlCommand: ControlCommand): SubmitResponse = {\n  controlCommand match {\n    case setup: Setup => handleSetup(runId, setup)\n    case observe      => Invalid(runId, UnsupportedCommandIssue(s\"$observe command not supported.\"))\n  }\n}\n\n/**\n * Processes commands as Setups\n * @param runId command runId\n * @param assemblySetup the [[Setup]] to execute\n * @return [[SubmitResponse]] response from the command. All commands are started currently.\n */\nprivate def handleSetup(runId: Id, assemblySetup: Setup): SubmitResponse = {\n  assemblySetup.commandName match {\n    case HcdShutdown.shutdownCommand =>\n      log.debug(s\"Segments Assembly received shutdown request: $runId and $assemblySetup\")\n      val hcdSetup = Setup(assemblyPrefix, HcdShutdown.shutdownCommand)\n\n      submitAndWaitHCD(runId, hcdSetup) map { sr =>\n        cswCtx.commandResponseManager.updateCommand(sr.withRunId(runId))\n      }\n      Started(runId)\n    case cmd =>\n      log.info(s\"Segments Assembly received a command: '$cmd',  runId: $runId, setup: $assemblySetup\")\n\n      // This simulates what the Assembly does to send to HCD - has received above Setup\n      try {\n        val hcdSetup: Setup = HcdDirectCommand.toHcdDirectCommand(assemblyPrefix, assemblySetup)\n        // Assembly sends the Setup and updates\n        submitAndWaitHCD(runId, hcdSetup) map { sr =>\n          log.info(s\"Assembly command completed from HCD: $sr\")\n          cswCtx.commandResponseManager.updateCommand(sr.withRunId(runId))\n        }\n        Started(runId)\n      }\n      catch {\n        case _: Exception =>\n          CommandResponse.Error(runId, s\"An exception was thrown while processing setup: ${assemblySetup.commandName}\")\n      }\n  }\n}\n\n/**\n * This is a convenience routine to check the availability of HCD prior to sending\n * @param runId command runId\n * @param setup the Setup to send\n * @return command response as a SubmitResponse\n */\nprivate def submitAndWaitHCD(runId: Id, setup: Setup): Future[SubmitResponse] =\n  hcdCS match {\n    case Some(cs) =>\n      // Added a delay here because segment commands take an unknown amount of time.\n      // Can be made an implicit for all calls in file for a more complex situation with different timeouts.\n      cs.submitAndWait(setup)(timeout = 15.seconds)\n    case None =>\n      Future(CommandResponse.Error(runId, s\"The Segment HCD is not currently available: ${hcdConnection.componentId}\"))\n  }\nAs before, the Observes return an Error (even through we can not get to this code in this example.) The handleSetup command must handle any named commands first. In this case, there is a command called shutdownCommand that when sent to the HCD, it causes all the segment connections to be closed and the HCD shutdown. This is useful for testing.\nThe second case matches on any other command. In this case, the function HcdDirectCommand.toHcdDirectCommand is called. If it does not fail (it is wrapped in a try clause), a Setup formatted for the HCD is returned and passed to the submitAndWaitHCD function. All this is doing is calling Command Service submitAndWait, but it is checking that the CommandService instance created for the HCD is valid before sending. (This will be covered later.) It also provides a custom timeout, which has been arbitrarily set to 15 seconds for all the segments to complete any command. If this time is exceeded, the submitAndWait will time out and return an error. Note that if the Command Service is not available, because the HCD is not available, an Error is also returned.\nThe function HcdDirectCommand.toHcdDirectCommand is shown below:\nScala copysource/**\n * This object contains the parameter keys for the command sent to the HCD to process a single\n * segment command. This is used by the segment Assembly and test code to produce an HCD Setup from\n * an Assembly Setup.\n */\ncase object HcdDirectCommand {\n\n  val lscsDirectCommand: CommandName = CommandName(\"lscsDirectCommand\")\n  // This key is used to store the command to be executed\n  val lscsCommandKey: Key[String]     = KeyType.StringKey.make(name = \"lscsCommand\")\n  val lscsCommandNameKey: Key[String] = KeyType.StringKey.make(name = \"lscsCommandName\")\n\n  /**\n   * This helper function returns a direct command Setup for the\n   * @param assemblyPrefix prefix of the Assembly as source\n   * @param assemblySetup the Setup received by the Assembly -contains segmentIdKey and command name\n   * @param obsId optional ObsId, defaults to None\n   * @return Setup ready for sending to HCD\n   */\n  def toHcdDirectCommand(assemblyPrefix: Prefix, assemblySetup: Setup, obsId: Option[ObsId] = None): Setup = {\n    val segmentIdExists    = assemblySetup.exists(segmentIdKey)\n    val segmentRangeExists = assemblySetup.exists(segmentRangeKey)\n    // Can't go on without one of these set\n    require(segmentIdExists || segmentRangeExists, s\"Bad segment info in the Assembly Setup: ${assemblySetup.commandName}\")\n\n    // Convert setup to a String command - note that we know this will work because we validated\n    val commandAsString = CommandMap(assemblySetup.commandName)(assemblySetup)\n\n    // Grab the command name from the first part of\n    require(commandAsString.nonEmpty, \"The command to the HCD must not be empty, fool!\")\n\n    Setup(assemblyPrefix, lscsDirectCommand, obsId).madd(\n      lscsCommandKey.set(commandAsString),\n      lscsCommandNameKey.set(assemblySetup.commandName.name),\n      assemblySetup(segmentIdKey)\n    )\n  }\n}\nFirst this function ensures that some required parameters are present in the Setup received by the Assembly. A require will throw an IllegalArgument exception if the condition is false. It then uses the CommandMap structure from Common (shown as part of validation) to extract the toCommand function for the command. This returns the String segment command as discussed in input. It checks that the command String is not empty.\nThen the HCD setup is constructed using parameters from the Assembly Setup and new ones from HcdDirectCommand. The command string is passed with the lscsCommandKey parameter, and the command name is within lscsCommandNameKey. The last entry pulls the segmentIdKey from the Assembly Setup and inserts it into the HCD setup.\nThe HCD Setup for the Assembly Setup:\nSetup(paramSet=Set(ACT_ID((1,3)none), MODE((TRACK)none), TARGET((22.34)none), \n  SegmentId((A23)none)), source=M1CS.hcdClient, commandName=CommandName(ACTUATOR), maybeObsId=None)\nis:\nSetup(paramSet=Set(lscsCommand((ACTUATOR ACT_ID=(1,3), MODE=TRACK, TARGET=22.34)none), \n      lscsCommandName((ACTUATOR)none), SegmentId((ALL)none)), \n      source=M1CS.segmentAssembly, commandName=CommandName(lscsDirectCommand), maybeObsId=None)","title":"Assembly Command Execution"},{"location":"/LSCSAssembly.html#handling-submitresponse-from-the-segments-hcd","text":"One last thing is that the Assembly must handle the SubmitResponse from the HCD. When the Assembly sends the HCD Setup to the HCD, a new runId is created for the command. When the command completes, the Assembly needs to pass an appropriate response back to the caller. This is handled by the following piece of code that is repeated fro above:\nsubmitAndWaitHCD(runId, hcdSetup) map { sr =>\n  cswCtx.commandResponseManager.updateCommand(sr.withRunId(runId))\n}\nStarted(runId)\nThe onSubmit handler sends the command using submitAndWaitHCD and then returns Started to the caller. This is a CSW long-running command (as opposed to an immediate-completion command). The HCD command runs asynchronously and returns a value in the future. When that occurs, the result is mapped to the closure shown, which calls the Assembly’s Command Response Manager with the SubmitResponse from the HCD, but it replaces the HCD runId with the Assembly Setup’s runId using withRunId. That’s all that is needed to handle the response from the HCD to the Assembly caller.\nThat’s the extent of the Setup processing in the Assembly.","title":"Handling SubmitResponse from the Segments HCD"},{"location":"/LSCSAssembly.html#tracking-the-hcd-and-creation-of-command-service","text":"The last bit of interesting code in the SegmentsAssemblyHandlers is how the SegmentsAssembly gets connection information about the Segments HCD, which it must have to send it commands.\nAs a reminder, connections (i.e. hosts and ports) are not hard-coded in CSW. When a component starts up, its Supervisor registers itself with the Location Service on behalf of the TLA and that location information includes enough information so that one component can create an appropriate connection to the other. CSW supports Akka-based connections and HTTP-based connections.\nWhen the Segments Assembly starts up its Component Configuration File contains an entry that indicates to the Supervisor that it wants to track the HCD. The “SegmentsAssemblyStandalone.conf” conf file is shown here.\nprefix = \"m1cs.segmentsAssembly\"\ncomponentType = assembly\nbehaviorFactoryClassName = \"m1cs.segments.assembly.SegmentsAssemblyBehaviorFactory\"\nlocationServiceUsage = RegisterAndTrackServices\nconnections = [\n  {\n    prefix: \"m1cs.segmentsHCD\"\n    componentType: hcd\n    connectionType: akka\n  }\n]\nThis file is discussed in the CSW documentation. The key in this discussion is that the connections array has an entry for the an HCD with prefix m1cs.segmentsHCD and connectionType: Akka. This indicates to CSW and the Supervisor of the Assembly that it should track the Segments HCD and deliver events to the Assembly when the Segments HCD is available and also when/if it shuts down or crashes. To receive tracking events, the assembly overrides the onLocationTrackingEvent handler as shown here.\nScala copysource/**\n * This is overriding tracking events to gain events for Segments HCD. The Assembly should be started\n * with a Component Configuration file that includes tracking and the info for the Segments HCD.\n * This is done in the test files for reference.\n * When the LocationUpdated event is received, a CommandService is created. When the\n * connection goes down, the CommandService is set to None. When None an error is issued in onSubmit.\n * @param trackingEvent CSW TrackingEvent.\n */\noverride def onLocationTrackingEvent(trackingEvent: TrackingEvent): Unit = {\n  log.debug(s\"onLocationTrackingEvent called: $trackingEvent\")\n  trackingEvent match {\n    case LocationUpdated(location) =>\n      log.debug(s\"Assembly received HCD location: $location\")\n      // Should be safe here since we are tracking only Akka location\n      val hcdLocation = location.asInstanceOf[AkkaLocation]\n      hcdCS = Some(CommandServiceFactory.make(hcdLocation)(ctx.system))\n    case LocationRemoved(connection) =>\n      if (connection == hcdConnection) {\n        hcdCS = None\n      }\n  }\n}\nThis code shows that the Assembly is handling two events: locationUpdated and locationRemoved. The locationUpdated is delivered when the HCD is registered and running. When this happens, the Assembly creates a CommandService instance for the HCD.\nIn the constructor of the Assembly is the following line:\nprivate var hcdCS: Option[CommandService] = None // Initially, there is no CommandService for HCD\nInitially this is set to None, meaning there is no Command Service (i.e. the HCD is not available). When the HCD is available, a CommandService instance is created and this variable is set to its value as shown.\nThen, when a command is sent and processed by the submitAndWaitHCD call way up in the Assembly Command Execution section, it checks the value of this Option. If present, the command is sent to the HCD. If None, an Error is returned to the caller.\nThis is an excellent way to track the availability of an Assembly or HCD using the builtin CSW functionality.","title":"Tracking the HCD and Creation of Command Service"},{"location":"/LSCSHcd.html","text":"","title":"LSCS Segments HCD"},{"location":"/LSCSHcd.html#lscs-segments-hcd","text":"The project includes a Segments HCD that processes segments commands. As discussed in the overview, the Segments HCD receives HCD Setups from the Assembly (or other sources), validates them and then sends them off to one or more segments. It monitors each of the segments for a response, which is hopefully success, but may be an error. Once all the segments complete successfully or if any segment completes with an Error, the HCD command is completed and a response is passed back to the caller. There are no events of any kind produced by the HCD.","title":"LSCS Segments HCD"},{"location":"/LSCSHcd.html#top-level-actor","text":"The Top Level Actor for Segments HCD can be found in the lscsComps project in the file named SegmentsHcdHandlers.scala, which contains the majority of the HCD code. As with all CSW components, the TLA for Segments HCD implements handlers as needed. In this HCD, only initialize, validateCommand, and onSubmit handlers are implemented. Unlike the Assembly, the HCD does not use the onLocationTrackingevent handler.","title":"Top Level Actor"},{"location":"/LSCSHcd.html#initialization","text":"Initialization in the Segments HCD does the important job of creating the Segments, which is discussed later. Here only the job of initializing the segments is done.\nScala copysource// Set this during initialization to be a Segments instance\nprivate var createdSegments: Segments = _\n\n/**\n * The TLA initialize reads the number of segments from the reference.conf file.  This is convenient for\n * testing. It creates that number of segments in each sector.  At some point this could be removed and\n * replaced with MAX_SEGMENT_NUMBER.\n */\noverride def initialize(): Unit = {\n  val segPath = \"m1cs.segments\"\n  val maxSegments =\n    if (ctx.system.settings.config.hasPath(segPath))\n      ctx.system.settings.config.getInt(segPath)\n    else SegmentId.MAX_SEGMENT_NUMBER\n  val segmentRange = 1 to maxSegments //SegmentId.MAX_SEGMENT_NUMBER\n  log.info(\n    s\"Initializing Segments HCD with ${segmentRange.max} segments in each sector for a total of ${segmentRange.max * SegmentId.ALL_SECTORS.size} segments.\"\n  )\n  createdSegments = SegmentManager.createSegments(creator, segmentRange, log)\n}\nAny state that is initialized in the initialize handler must be global to the TLA. In this case, there is a variable called createdSegments of type Segments that is set during initialize. The segments value is managed by the SegmentManager object, but it is essentially a Map of SegmentId values to SegmentActor references. The variable createdSegments is used by the onSubmit handler.\nAs shown, the code gets the maxSegments value from the reference.conf file and hands it to the SegmentManager to create segments. As mentioned before, the Segment Manager will create that number of segments in each sector. Therefore, the maximum value for maxSegments is MAX_SEGMENT_NUMBER and once one is happy with the simulator, the check can either be eliminated or set to 82 in the reference.conf file.","title":"Initialization"},{"location":"/LSCSHcd.html#hcd-command-validation","text":"As in the Assembly, an Observe is rejected and the Setup is passed to another function for validation. The validateCommand handler is shown below.\nScala copysource/*\n * All Setup validation is performed here. Three checks are done for a lscsDirectCommand:\n * 1. is there a valid LSCS command\n * 2. is there a segmentId key (one or all)\n * 3. If one segment, is the segment available?\n * The HCD shutdown command is also accepted.  All others are rejected.\n */\nprivate def handleValidation(runId: Id, setup: Setup): ValidateCommandResponse = {\n  setup.commandName match {\n    case HcdDirectCommand.lscsDirectCommand =>\n      if (!setup.exists(lscsCommandKey))\n        Invalid(runId, CommandIssue.MissingKeyIssue(s\"Setup must include the ${lscsCommandKey.keyName} parameter.\"))\n\n      if (!setup.exists(segmentIdKey))\n        Invalid(runId, CommandIssue.MissingKeyIssue(s\"Setup must include the ${segmentIdKey.keyName} parameter.\"))\n\n      // Verify that if one segment, that the segment is online in the list\n      val segmentIdValue = setup(segmentIdKey).head\n      if (segmentIdValue != ALL_SEGMENTS && !createdSegments.segmentExists(SegmentId(segmentIdValue))) {\n        Invalid(\n          runId,\n          CommandIssue.ParameterValueOutOfRangeIssue(s\"The segmentId: $segmentIdValue is not currently available.\")\n        )\n      }\n      else {\n        Accepted(runId)\n      }\n    case HcdShutdown.shutdownCommand =>\n      Accepted(runId)\n    case other =>\n      Invalid(runId, CommandIssue.UnsupportedCommandIssue(s\"HCD does not accept the command: $other\"))\n  }\n}\nThe HCD can process two commands: lscsDirectCommand and shutdownCommand. For lscsDirectCommand handleValidation does three things:\nIs the lscsCommandKey present? If not, return Invalid. Is a segmentIdKey included? If not, return Invalid. Finally, if the destination is a single segment, check to see if the destination segment is “online”. Since we can configure the number of segments to create, it’s possible to send a command to a segment that does not exist. If this check fails, return Invalid.\nIf these three things pass, the Setup is Accepted. There is probably more that could be done but that’s it for now. We are assuming that the input/output library is used to constructing the Setups so no checks for required parameters are done.\nThe HCD also accepts the HcdShutdown.shutdownCommand. This command is always accepted.\nIf any other command is received by the HCD, it is rejected and Invalid is returned.","title":"HCD Command Validation"},{"location":"/LSCSHcd.html#segments-hcd-command-execution","text":"Once validated, the onSubmit handler is called. Like the Assembly, the HCD rejects Observes and hands off execution to handleSetup. Checking for Observe again isn’t needed since it is done in validation. HandleSetup is reproduced below. This is the crux of the HCD.\nScala copysource/**\n * Processes commands as Setups for the HCD.\n * @param runId command runId\n * @param setup the [[Setup]] to execute\n * @return [[SubmitResponse]] response from the command. All commands are started currently.\n */\nprivate def handleSetup(runId: Id, setup: Setup): SubmitResponse = {\n  setup.commandName match {\n    case HcdDirectCommand.lscsDirectCommand =>\n      // We know all these params are present at this point\n      val command         = setup(lscsCommandKey).head\n      val commandName     = setup(lscsCommandNameKey).head\n      val segmentKeyValue = setup(segmentIdKey).head\n      // The sendList, at this point, is either one segment or all segments.  The same execution approach\n      // is used regardless of one or all\n      val sendList = if (segmentKeyValue == ALL_SEGMENTS) {\n        createdSegments.getAllSegments\n      }\n      else {\n        createdSegments.getSegment(segmentId = SegmentId(segmentKeyValue))\n      }\n\n      // Here a SegComMonitor is created to send and watch for completion of the command. The sendList is the\n      // list of SegmentActors that will receive the command.  The function passed as the 5th argument will\n      // be executed when all the segment commands complete either successfully or with an error.\n      val mon1 = ctx.spawnAnonymous(\n        hcd.SegComMonitor(\n          commandName,\n          command,\n          sendList.segments,\n          runId,\n          (sr: SubmitResponse) => cswCtx.commandResponseManager.updateCommand(sr),\n          log\n        )\n      )\n      // Start the command and return Started to the Assembly\n      mon1 ! SegComMonitor.Start\n      Started(runId)\n    case HcdShutdown.shutdownCommand =>\n      //This just sends shutdown to all the online segments\n      createdSegments.shutdownAll()\n      Completed(runId)\n    case other =>\n      Error(runId, s\"This HCD does not handle this command: $other\")\n  }\n}\nThere are two commands, lscsDirectCommand, and shutdownCommand.","title":"Segments HCD Command Execution"},{"location":"/LSCSHcd.html#lscsdirectcommand-implementation","text":"The first thing that occurs is the command name, the segment destination, and the command String are extracted from the Setup. Then the segmentKeyValue, which is either ALL_SEGMENTS or a specific segment ID is tested for and used to access a list of segments for the command. It calls SegmentManager to return on or all.\nThen a SegComMonitor actor is created, which takes the command String, the list of segments, the runId of the request, and a function to execute when all the segments have completed. The SegComMonitor.Start message is sent to the monitor, which causes the sending of the command to all the segments.\nJust as a note in case it is not clear. These lscsDirectCommands executed by the HCD are totally asynchronous. As you can see from the code, once a monitor is started, the submit-handler returns Started indicating to the caller that a long- running command is started. The HCD is then available to accept and process another HCD/segment command, which starts its own SegComMonitor. The tests demonstrate that this works.","title":"lscsDirectCommand Implementation"},{"location":"/LSCSHcd.html#segment-monitor","text":"Segment Monitor is the longest piece of code in the project. Segment Monitor is an actor implementing a two state finite state machine that has the job of executing a segment command and waiting for responses. The code is long but is included here.\nScala copysource/**\n * These are the commands for the Command Sequence Monitor. The WrappedSegmentResponse is needed to receive\n * the SegmentActor.Response and transform it into a SegComMonitor.Command.\n * CommandTimeout is is issued and received if the Command Monitor times out before receiving all segment responses.\n */\nsealed trait Command\nfinal private case class WrappedSegmentResponse(response: SegmentActor.Response) extends Command\ncase object Start                                                                extends Command\nfinal private case object CommandTimeout                                         extends Command\n\n/**\n * This private class implements the Segment Command Monitor.\n * The class is an actor with a two state FSM. The monitor is created with a list of segment actors and a\n * segment command that is to be sent to each of the segment actors in the list. It waits for the Start message\n * in the `starting` state. Once Start is received, it sends to command sequentially to each segment actor and\n * waits for the responses in the `waiting` state.\n *\n * It determines completion by counting responses and also checking that the responses are Completed rather than Error.\n * Once the correct number of responses have been received, it executes the replyTo function, which is usually a\n * function to update the CSW CRM, which notifies the caller that the command is completed.\n *\n * There is one more feature.  A timeout can be provided that will allow the command to timeout and reply to the\n * caller with an Error.\n *\n * A new Segment Command Monitor is created for every command executed, after all the responses have been received or\n * the monitor is otherwise completed, the monitor returns Behaviors.stopped, which causes the actor to be ended.\n */\nclass SegMonitor private[SegComMonitor] (\n    commandName: String,\n    fullCommand: String,\n    segments: List[ActorRef[SegmentActor.Command]],\n    runId: Id,\n    replyTo: SubmitResponse => Unit, // This is here so that handler can provide the CRM but tests can do something else\n    log: Logger,\n    segmentResponseMapper: ActorRef[SegmentActor.Response],\n    timeout: FiniteDuration\n) {\n  def starting(): Behavior[Command] =\n    Behaviors.receiveMessage {\n      case Start =>\n        log.debug(s\"Sending $commandName to ${segments.size} segments.\")\n        segments.foreach(_ ! SegmentActor.Send(commandName, fullCommand, segmentResponseMapper))\n        waiting(segments.size, responsesReceived = 0)\n      case _ =>\n        Behaviors.unhandled\n    }\n\n  /**\n   * The waiting state is entered once the command is sent to the segments. Every time a response from a segment\n   * is received, the Behavior calls itself with updated state. This is not a recursive call in Akka.\n   * @param totalSegments the number of expected responses\n   * @param responsesReceived number of responses received so far\n   * @return a typed Behavior\n   */\n  def waiting(totalSegments: Int, responsesReceived: Int): Behavior[Command] =\n    Behaviors.withTimers { timers =>\n      Behaviors\n        .receiveMessage[Command] {\n          case wrapped: WrappedSegmentResponse =>\n            wrapped.response match {\n              case SegmentActor.Started(commandName, commandId, segmentId) =>\n                timers.startSingleTimer(TIMEOUT_KEY, CommandTimeout, timeout)\n                log.debug(s\"Started: $segmentId:$commandName:$commandId with $timeout timeout.\")\n                Behaviors.same\n              case SegmentActor.Completed(commandName, commandId, segmentId) =>\n                val updatedResponsesReceived = responsesReceived + 1\n                if (totalSegments == updatedResponsesReceived) {\n                  log.info(\n                    s\"$commandName completed successfully for **$updatedResponsesReceived** segments. Sending Completed($runId)\"\n                  )\n                  log.debug(s\"Cancelling Timeout Timer\")\n                  timers.cancel(TIMEOUT_KEY)\n                  replyTo(Completed(runId))\n                  Behaviors.stopped\n                }\n                else {\n                  if (Math.floorMod(responsesReceived, 20) == 0)\n                    log.debug(s\"Completed: $segmentId:$commandName:$commandId  Total completed: $responsesReceived\")\n                  waiting(totalSegments, updatedResponsesReceived)\n                }\n              case SegmentActor.Processing(commandName, commandId, segmentId) =>\n                log.debug(s\"Processing: $segmentId:$commandName:$commandId\")\n                Behaviors.same\n              case SegmentActor.Error(commandName, commandId, segmentId, message) =>\n                val updatedResponsesReceived = responsesReceived + 1\n                log.error(\n                  s\"Error: $segmentId:$commandName:$commandId--STOPPING, $updatedResponsesReceived responses received.\"\n                )\n                // Cancel the timeout timer\n                timers.cancel(TIMEOUT_KEY)\n                replyTo(Error(runId, message))\n                Behaviors.stopped\n            }\n          case Start =>\n            Behaviors.unhandled\n          case CommandTimeout =>\n            replyTo(\n              Error(\n                runId,\n                s\"A segment command timed out after receiving: $responsesReceived responses of expected: $totalSegments.\"\n              )\n            )\n            Behaviors.stopped\n          case other =>\n            log.error(s\"SegComMonitor received some other message.  Just FYI: $other\")\n            Behaviors.same\n        }\n        .receiveSignal { case (_, PostStop) =>\n          log.debug(s\">>>SegComMonitor for $runId STOPPED<<<\")\n          Behaviors.same\n        }\n    }\n}\nSegComMonior is created in the starting state, awaiting the start message from the HCD TLA. When received, it sends the full segment command to each of the SegmentActors on the list passed into the monitor from the TLA (it will be 1 segment or a list of all segments). Once the commands are sent, it moves to the waiting state.\nThe state is called waiting because it is waiting for the responses from the SegmentActors. First note that waiting starts a timer so that if something goes wrong in a SegmentActor, after a timeout period, the CommandTimeout message will be sent to itself, which will cause an Error SubmitResponse to be returned to the runId through the replyTo function.\nThe monitor is written to assume the SegmentActor will return responses as described in the M1CS docs including Started, and Processing, and Error messages. The happy case is the SegmentActor.Completed message. All the monitor does is count happy responses until it receives the correct number, it then sends Completed to the runId through the replyTo function.\nIf a single Error is returned, the monitor stops immediately–if a single segment produces an error out of all segments, it means the command fails immediately, and an Error is returned to the client through the runId and replyTo function.\nThe important part for completion is the code around the SegmentActor.Completed message. Whenever a segment returns a positive response, the count is incremented and waiting is called again (which appears recursive, but actually isn’t). Once all the responses are received, the Completed SubmitResponse is sent to the caller through the replyTo function. The Behavior of the monitor becomes Behaviors.stopped, which causes the monitor actor to stop.\nNote The SegComMonitor is written in the functional typed actor style. See akka.io.\nWarning Neither simulator implements the protocol that includes: Processing and Started messages. We suggest they not be implemented and keep the low-level protocol simple. The Segment Actor tries to implement some features of the protocol, but it has little effect on the monitor or the HCD and Assembly, there is very little reason to send Started if the command is longer than 1 second or Processing messages. They provide no useful information at this level and just introduce potential for errors. This might be useful for a command-line UI, but that isn’t the application here. We suggest dropping this since it isn’t part of the JPL library.\nSegComMonitor tests are a good way to see how testing works and how we validate the M1CS requirement to complete all segment commands and complete a CSW command.\nThe following test shows sending a command to 492 segments and waiting for completion. First the SegmentManager is used to create a full mirror configuration. This is what the HCD does during initialization The tester is a function that notifies the com1Response TestProbe when the command completes.\nThen a SegComMonitor is created with a test command and the list of 492 segments. It is then started, which causes the command to be sent to all the segments. Then the test code waits for the Compleiton message. Once received as a precaution it waits to see if any other messages arrive, then shutsdown all the segment connections and quits.\nScala copysourcetest(\"492 segments - send 1 - external\") {\n  // Note: This test fails on Mac, server must be running on Linux due to open file issue?\n\n  val range = 1 to SegmentId.MAX_SEGMENT_NUMBER\n  // Create segments\n  val segments      = SegmentManager.createSegments(testCreator, range, log)\n  val segmentActors = segments.getAllSegments.segments\n  segmentActors.size shouldBe 492\n\n  val com1Response = TestProbe[SubmitResponse]()\n  val tester       = makeTester(com1Response)\n\n  val runId1 = Id()\n  val mon    = testKit.spawn(hcd.SegComMonitor(cn1, cn1full, segmentActors, runId1, tester, log))\n  mon ! SegComMonitor.Start\n\n  // This verifies that both commands finished successfully\n  com1Response.expectMessage(10.seconds, Completed(runId1))\n\n  // Wait for final logs\n  com1Response.expectNoMessage(100.milli)\n  segments.shutdownAll()\n\n  testKit.stop(mon, 5.seconds)\n}\nThe following code is similar but in this case, the test starts and executes two overlapping segment commands and waits for them both to asynchronously complete either successfully or with an error.\nScala copysourcetest(\"492 segments - overlap - external\") {\n  // Note: This test fails on Mac, server must be running on Linux due to open file issue?\n\n  val range = 1 to SegmentId.MAX_SEGMENT_NUMBER\n  // Create segments\n  val segments      = SegmentManager.createSegments(testCreator, range, log)\n  val segmentActors = segments.getAllSegments.segments\n  segmentActors.size shouldBe 492\n\n  val com1Response = TestProbe[SubmitResponse]()\n  val tester       = makeTester(com1Response)\n\n  val runId1 = Id()\n  val mon1   = testKit.spawn(hcd.SegComMonitor(cn1, cn1full, segmentActors, runId1, tester, log))\n  mon1 ! SegComMonitor.Start\n\n  val runId2 = Id()\n  val mon2   = testKit.spawn(hcd.SegComMonitor(cn2, cn2full, segmentActors, runId2, tester, log))\n  mon2 ! SegComMonitor.Start\n\n  // This verifies that both commands finished successfully\n  val messages = com1Response.receiveMessages(2, 15.seconds)\n  messages.size shouldBe 2\n  val resultRunIds = Set(messages.head.runId, messages(1).runId)\n  resultRunIds.contains(runId1) shouldBe true\n  resultRunIds.contains(runId2) shouldBe true\n\n  // Wait for final logs or shutdown\n  com1Response.expectNoMessage(100.milli)\n  segments.shutdownAll()\n\n  testKit.stop(mon1, 5.seconds)\n  testKit.stop(mon2, 5.seconds)\n}\nAt least with the JVM simulator, it is not known which command will complete first because of the randomized delays, so the test waits for 2 messages and then checks that they are the correct messages.","title":"Segment Monitor"},{"location":"/LSCSHcd.html#segment-actor","text":"The Segments HCD creates a SegmentActor instance for each configured segment. The SegmentActor is a wrapper for the class called SocketClientStream, which is the low-level communication with the segment and which implements the JPL-library protocol. The code below is the interesting part of SegmentActor.\nScala copysourceobject SegmentActor {\n\n  // The following is temp hack for testing errors\n  val ERROR_SEG_ID: Int                = 6\n  val ERROR_COMMAND_NAME: String       = \"ERROR\"\n  val FAKE_ERROR_MESSAGE: String       = \"Fake Error Message\"\n  private implicit val timout: Timeout = Timeout(5.seconds)\n\n  def apply(segmentId: SegmentId, log: Logger): Behavior[Command] = {\n    Behaviors.setup[Command] { ctx =>\n      // Here we check to see if there is a property called simulatorHost\n      val simulatorHost          = Properties.propOrElse(\"simulatorHost\", \"localhost\")\n      val io: SocketClientStream = SocketClientStream(ctx, segmentId.toString, host = simulatorHost)\n      handle(io, seqNo = 1, segmentId, log)\n    }\n  }\n\n  private def getRandomDelay: FiniteDuration = FiniteDuration(Random.between(10, 1250), MILLISECONDS)\n\n  private def handle(io: SocketClientStream, seqNo: Int, segmentId: SegmentId, log: Logger): Behavior[Command] =\n    Behaviors.receive[Command] { (ctx, m) =>\n      import ctx.executionContext\n      m match {\n        case Send(commandName, args, replyTo) =>\n          ctx.self ! SendWithTime(commandName, args, getRandomDelay, replyTo)\n          handle(io, seqNo, segmentId, log)\n\n        case SendWithTime(commandName, _, delay, replyTo) =>\n          // The following fakes JPL Started until sim does it\n          if (delay.toMillis > 1000)\n            replyTo ! Started(commandName, seqNo, segmentId)\n\n          // Right now simulator just does random delays\n          val simCommand = s\"DELAY ${delay.toMillis.toString}\"\n          io.send(simCommand).onComplete {\n            case Success(_) =>\n              // The value returned from the simulator is not used at this point.  That could change.\n              // Message from simulator not used at this point\n              if (commandName == ERROR_COMMAND_NAME)\n                replyTo ! Error(commandName, seqNo, segmentId, FAKE_ERROR_MESSAGE)\n              else\n                replyTo ! Completed(commandName, seqNo, segmentId)\n            case Failure(exception) =>\n              log.error(s\"Socket send failed: $exception\", ex = exception)\n              replyTo ! Error(commandName, seqNo, segmentId, \"Error received from simulator.\")\n          }\n          handle(io, seqNo + 1, segmentId, log)\nFirst, when the SegmentActor is created in the apply def function. This is where the lower level SocketClientStream class is added and where the socket connection to the LSCS occurs.\nThe rest of the actor is a mix of trying to make the system behave like the documentation and interfacing to the current simulator.\nFor instance, the feature of sending a Started to the caller when the command takes greater than 1 second was added to ensure the system can handle that eventually. This is also true with the Processing message.\nNote But as it turns out, the higher level software and CSW can not do anything with these Started and Processing messages, so they should just be dropped.\nSegmentActor has two messages related to sending a message to the segment. The first is Send, which is the operational case. It sends a command to the segment. The second is SendWithTime, which allows sending a time for the simulator delay to allow easier testing of things like multiple commands and overlapping commands.\nAt this level, all segment commands are implemented as a variable delay on the segment side of the socket. We send the command: DELAY MILLIS such as DELAY 1234 to the socket client. The delay is random returned by the getRandomDelay function. The delay is currently set to be between 10 and 1250 millis.\nThe important message of SegmentActor is the processing under SendWithTime. The code checks to see if the delay is greater than 1 second, if so it sends a Started message back to the caller. Then it uses the send method of the socket client to send the command to the segment socket. This is an asynchronous call using a Future. When the call completes, the SegmentActor sends a response to the caller, which is a SegComMon instance to be counted.\nThe ShutdownSegment command is also handled. When this occurs, the client is terminated, which closes the socket connection to the segment. These shutdown commands are present so that tests always work correctly.","title":"Segment Actor"},{"location":"/LSCSSimulator.html","text":"","title":"LSCS Simulator and JPL Simulator"},{"location":"/LSCSSimulator.html#lscs-simulator-and-jpl-simulator","text":"The JVM simulator server is implemented in the SocketServerStream class. It implements the same low level protocol as the JPL C library, located in the m1cs-lscs-sim subproject. The main difference in the current version is that the Scala version of the server supports a “DELAY ms” command, which is used to simulate a command that takes ms milliseconds to complete. For testing, it also takes a q command that causes the server to shut down.","title":"LSCS Simulator and JPL Simulator"},{"location":"/LSCSSimulator.html#starting-the-socket-server","text":"For testing, the JVM socket server can be started with:\nnew SocketServerStream()(actorSystem)\nThe C version of the server can be started with the CmdSrvSim command. See the README.md in the m1cs-lscs-sim subproject for details on the C version.","title":"Starting the Socket Server"},{"location":"/LSCSSimulator.html#creating-a-socket-client","text":"In order to create a socket client, you need either an ActorSystem[SpawnProtocol] or an ActorContext, since the client needs to create an actor internally, in order to manage responses.\nTo use an ActorSystem, use the SocketClientStream.withSystem() method:\nimplicit val system: ActorSystem[SpawnProtocol.Command] = ActorSystem(SpawnProtocol(), \"SocketServerStream\")\n  // ...\n  val client1 = SocketClientStream.withSystem(\"client1\")\nIf you are already in an actor, you can use the ActorContext instead (used only in the same thread to create a child actor):\nBehaviors.setup[Command] { ctx =>\n      val io = SocketClientStream(ctx, name)\n      // ...\n    }\nBoth methods have optional arguments for the host and port to use to connect to the server. The deault is localhost:8023, which is the same default used by the C library.","title":"Creating a Socket Client"},{"location":"/LSCSSimulator.html#sending-messages-to-the-server","text":"The class used to access the socket server is SocketClientStream and it can talk to either the C or the Scala version of the server.\nThe API for the client is basically just: send(message), which returns a non-blocking Future response:\nScala copysourceimplicit val system: ActorSystem[SpawnProtocol.Command] = ActorSystem(SpawnProtocol(), \"SocketServerStream\")\nimplicit val ece: ExecutionContextExecutor              = system.executionContext\nimplicit val timout: Timeout                            = Timeout(30.seconds)\n\n// Start the server\nnew SocketServerStream()(system)\n\ntest(\"Basic test\") {\n  val client1 = SocketClientStream.withSystem(\"client1\")\n  val client2 = SocketClientStream.withSystem(\"client2\")\n  val client3 = SocketClientStream.withSystem(\"client3\")\n\n  def showResult(msg: SocketMessage): SocketMessage = {\n    println(s\"XXX showResult: $msg\")\n    msg\n  }\n  val f0 = client1.send(\"IMMEDIATE\").map(showResult)\n  val f1 = client1.send(\"DELAY 2000\").map(showResult)\n  val f2 = client2.send(\"DELAY 1000\").map(showResult)\n  val f3 = client3.send(\"DELAY 500\").map(showResult)\n  val f4 = client1.send(\"DELAY 200\").map(showResult)\n  val f5 = client2.send(\"IMMEDIATE\").map(showResult)\n\n  val f = for {\n    resp0 <- f0\n    resp1 <- f1\n    resp2 <- f2\n    resp3 <- f3\n    resp4 <- f4\n    resp5 <- f5\n  } yield {\n    client1.terminate()\n    client2.terminate()\n    client3.terminate()\n    List(resp0, resp1, resp2, resp3, resp4, resp5)\n  }\n  val list = Await.result(f, 30.seconds)\n  println(s\"XXX test1 result = $list\")\n  assert(list.forall(_.cmd.endsWith(\" COMPLETED\")))\n}\nThe type of the message sent is SocketMessage, which has the same layout as the JPL C socket message:\nScala copysource/**\n * The type of a message sent to the server (also used for the reply).\n *\n * @param hdr message header\n * @param cmd the actual text of the command\n */\ncase class SocketMessage(hdr: MsgHdr, cmd: String) {\nIn most cases you don’t need to provide the message header, since it is generated automatically from the message text. It contains information, such as the size of the message and a sequence number, which is also returned as part of the response. The header is represented by the MsgHdr class, below:\nScala copysource/**\n * @param msgId message type\n * @param srcId sender application id\n * @param msgLen message length including header(bytes\n * @param seqNo sequence number\n */\ncase class MsgHdr(msgId: MessageId, srcId: SourceId, msgLen: Int, seqNo: Int)\nThe type of the response to sending a command is the same (SocketMessage).","title":"Sending Messages to the Server"},{"location":"/LSCSSimulator.html#stopping-the-server","text":"For testing, you can use the terminate() method on the client to cause the server to shutdown, ending the connection. This is not supported in the C version.","title":"Stopping the Server"},{"location":"/LSCSSimulator.html#wire-format","text":"The wire format for a socket message is based on the C library version and uses the same header and byte order.","title":"Wire Format"},{"location":"/Deploy.html","text":"","title":"Segments Assembly and HCD Deployment"},{"location":"/Deploy.html#segments-assembly-and-hcd-deployment","text":"This is a development project and is not set up to deploy final products; therefore, it is necessary to check out the repository and build the Assembly/HCD, etc. following typical sbt build, test, publish, etc. See the CSW docs at at CSW GitHub.","title":"Segments Assembly and HCD Deployment"},{"location":"/Deploy.html#starting-csw-services","text":"The test code starts any needed services, such as Location Service, during the tests, but if you want to test the Assembly or HCD outside of the testing environment, you must start CSW Services. This is described here. This demonstration does not use many services, so starting with -e is adequate.\ncsw-services start -e\nWarning You can not run the tests and have csw-services also running. You will get errors.","title":"Starting CSW Services"},{"location":"/Deploy.html#launching-with-sbt","text":"For demonstration or testing it is easiest to start the Assembly, HCD or both from the sbt build tool as shown here. This can be done from the shell or within sbt.\nThere is a directory in the distribution called lscs-deploy. Within the directory is a resources file that contains three ComponentConfigurationFiles as described here:\nFile Description SegmentsAssemblyStandalone.conf Starts the Assembly only standalone SegmentsHcdStandalone.conf Starts the HCD only standalone SegmentsContainer.conf Starts both the Assembly and HCD in a container\nThe third option that starts a container with Assembly and HCD is the most useful when testing externally.\nTo launch the container from the command line, type:\nsbt \"lscs-deploy/runMain m1cs.segments.deploy.SegmentsContainerCmdApp --local src/main/resources/SegmentsContainer.conf\"\nFrom within sbt use the runMain option:\nlscs-deploy/runMain m1cs.segments.deploy.SegmentsContainerCmdApp --local src/main/resources/SegmentsContainer.conf\nIn this case, both the Assembly and HCD are started within the same process in a CSW container, which does little other than manage the creation and shutdown of the components. There is no performance penalty for using a container.\nTo launch a standalone conf you must add the -standalone option, but everything else is the same:\nsbt \"lscs-deploy/runMain m1cs.segments.deploy.SegmentsContainerCmdApp --standalone --local src/main/resources/SegmentsContainer.conf\"","title":"Launching With sbt"},{"location":"/TestingAndShell.html","text":"","title":"Testing LSCS Code and Using esw-shell"},{"location":"/TestingAndShell.html#testing-lscs-code-and-using-esw-shell","text":"This section describes the testing and ties the goals of the demonstration to test verification. It also shows how to use esw-shell to send commands to the assembly.","title":"Testing LSCS Code and Using esw-shell"},{"location":"/TestingAndShell.html#testing-strategy","text":"The strategy here demonstrates one approach to testing. Others rely on mocks to minimize integration tests, but with the level of difficulty in an Assembly and HCD, direct testing is not too difficult.\nThe approach in this project is that every major class has its own unit tests. As the project progresses higher in the chain more components are involved, which have been unit tested, resulting in a tested component. The following table shows classes and tests:\nClass Test Project Description SegmentId SegmentIdTests lscsCommands Tests for the SegmentId type, Sector, and SegmentRange command classes SegmentCommandsTests lscsCommands Tests for all commands are in this one file. This could be broken out. SocketMessage SocketMessageTest lscsComps Tests for JPL message format. SocketClientStream SocketClientStreamTest lscsComps Tests the protocol to the simulator SegmentActor SegmentActorTests lscsComps Tests basic functionality of Segment Actor talking over client stream SegComMonitor SegComMonitorTests lscsComps Tests multi-segment commands and completion SegmentsHcdHandlers SegmentsHcdTests lscsComps Tests that HCD receives Setups and sends to segments properly SegmentsAssemblyHandlers SegmentsAssemblyIntTests lscsComps Integration tests of end-to-end Assembly receives Setups and sends on to HCD, etc. SegmentsAssemblyHandlers SegmentsAssemblyTests lscsComps Tests that Assembly outputs the correct Setup when processing. Uses “mock” HCD\nTypically, the tests are run from Intellij. In most cases all tests run without issues, but there are some cases where tests will fail because a previous test is not finished completely. I have not taken the time to wring out all these issues.\nThere is also the issue with 492 segment tests failing on macOS as mentioned in other places.","title":"Testing Strategy"},{"location":"/TestingAndShell.html#use-of-esw-shell-for-testing","text":"ESW-shell is an application that is distributed as part of ESW (it was previously known as csw-shell). It is a command-line interactive user interface that can be used to communicate and control CSW and ESW services and applications. The installation of ESW-shall is described in the ESW documents here.","title":"Use of esw-shell for Testing"},{"location":"/TestingAndShell.html#setting-up-to-use-esw-shell","text":"Setting things up can be a bit complicated. There are a number of considerations when testing:\nDo I want to use the JVM-based simulator or the external JPL simulator? Am I on Linux? Should the JVM-based simulator run from within IDE or not? Is csw-services started? Should I start the Assembly and HCD separately or in a container?\nSo before using esw-shell successfully, CSW services must be running, a simulator must be running, and the Segments Assembly and HCD must be running. The following will show one approach.","title":"Setting Up To Use esw-shell"},{"location":"/TestingAndShell.html#install-and-run-csw-services","text":"Follow the instructions here to install csw-services. Only Location Service is needed, but you must start with an option.\ncsw-services -e\nThis starts csw-services with Location Service and Event Service","title":"Install and Run csw-services"},{"location":"/TestingAndShell.html#start-the-lscs-simulator","text":"The JVM-based Simulator can be started using sbt:\nsbt \"lscsComps/runMain m1cs.segments.streams.server.SocketServerStream\"\nor\nsbt\nproject lscsComps\nrun\nAnd select the SocketServerStream app.\nNote You may also start the simulator on a different machine and use the -DsimulatorHost option to indicate where the simulator is located. This causes the SegmentActor to connect to the port 8023 on the host indicated. This is a good way to keep a simulator runing on a Linux machine.","title":"Start the LSCS Simulator"},{"location":"/TestingAndShell.html#starting-the-segments-assembly-and-segments-hcd","text":"There are component configuration files for standalone HCD and Assembly as well as a container configuration file that includes both. That is the most convenient. Use sbt to start the two in a container as discussed in the deploy section.\nsbt \"lscs-deploy/runMain m1cs.segments.deploy.SegmentsContainerCmdApp --local src/main/resources/SegmentsContainer.conf\"\nor for a remote LSCS Simulator:\nsbt \"lscs-deploy/runMain m1cs.segments.deploy.SegmentsContainerCmdApp --local src/main/resources/SegmentsContainer.conf -DsimulatorHost=192.168.1.230\"","title":"Starting the Segments Assembly and Segments HCD"},{"location":"/TestingAndShell.html#loading-and-executing-segment-commands","text":"At this point, CSW services are running, the LSCS Simulator is running, and the Segments Assembly/HCD are running.\nThe lscsCommands project is created to only include the functions that create Segment Assembly Setups. This means it can be loaded into esw-shell and used to send commands to the Segments Assembly.\nThe file scripts/commands.sc contains a small introduction that shows how to use esw-shell to send commands to SegmentsAssembly.\nBy default, esw-shell includes imports of all the major CSW libraries. It also includes some helpers for doing typical operations. First you must import the code needed to create commands. This is present in the example script, so you can copy/paste.\n// This is needed to resolve TMT libraries (even though they are already present)\nimport $repo.`https://jitpack.io`\n\n// This loads the lscscommands JAR file.  If you change the version, you must update this also.\ninterp.load.ivy(\"com.github.tmtsoftware.m1cs\" %% \"lscscommands\" % \"0.0.1-SNAPSHOT\")\n\n// These imports are needed to send the 10 implemented commands\nimport m1cs.segments.segcommands._\nimport m1cs.segments.segcommands.Common._\nimport Common.CfgLoopModes._\nimport Common.ControllerModes._\nimport ACTUATOR.ActuatorModes._\nimport TARG_GEN_ACT.TargetGenModes._\nimport TARG_GEN_ACT.TargetShapes._\nimport CFG_CUR_LOOP.CfgCurLoopMotor._\nimport SET_LIMIT_ACT.PositionSensors._\nimport SET_PARAM_ACT.Motors._\nimport MOVE_WH.MoveTypes._\nimport MOVE_WH.Torques._\nimport MOVE_WH.Boosts._\nAt this point, any of the commands can be executed. Here is how to send an ACTUATOR command to segment C9.\n// A test prefix \nval prefix = Prefix(\"ESW.test\")\n\n// Create an ACTUATOR command.\nval ac = ACTUATOR.toActuator(prefix, Set(1,3)).withMode(TRACK).toSegment(SegmentId(\"C9\"))\n\n// Create a Command Service for the Segments Assembly. This uses the Location Service to find the Assembly\nval segA = assemblyCommandService(\"M1CS.segmentsAssembly\")\n\n// Get the Assembly Setup for the command and send it to the Assembly \nval result = segA.submitAndWait(ac.asSetup).get\nThe submitAndWait stops and waits until the command is completed. The get on the code waits for the Future to complete and returns the value.\nAlong the way, the entered lines will print out results (and error messages). For instance the commands above also printed out:\nval ac = ACTUATOR.toActuator(prefix, Set(1,3)).withMode(TRACK).toSegment(SegmentId(\"C9\"))\nac: ACTUATOR.toActuator = toActuator(prefix = Prefix(subsystem = ESW, componentName = \"test\"), actId = Set(1, 3))\n\nval s = ACTUATOR.toActuator(prefix, Set(1,3)).withMode(TRACK).toSegment(SegmentId(\"C9\")).asSetup\ns: Setup = Setup(\n  source = Prefix(subsystem = ESW, componentName = \"test\"),\n  commandName = CommandName(name = \"ACTUATOR\"),\n  maybeObsId = None,\n  paramSet = Set(\n    Parameter(keyName = \"ACT_ID\", keyType = IntKey, items = ArraySeq(1, 3), units = none),\n    Parameter(keyName = \"MODE\", keyType = ChoiceKey, items = ArraySeq(Choice(name = \"TRACK\")), units = none),\n    Parameter(keyName = \"SegmentId\", keyType = StringKey, items = ArraySeq(\"C9\"), units = none)\n  )\n)\n\n// Note that the segmentId does not appear in the command sent to the segment\nval c = ACTUATOR.toCommand(s)\nc: String = \"ACTUATOR ACT_ID=(1,3), MODE=TRACK\"\nCommands such as the above can be saved into “scripts”, that can then be loaded. There is a learning curve to using esw-shell, but usually, the issues are around imports and syntax.","title":"Loading and Executing Segment Commands"},{"location":"/Goals.html","text":"","title":"Goals Summary"},{"location":"/Goals.html#goals-summary","text":"The following provides follow-up of the goals of lscs-example first discussed in the document overview and references to any supporting documentation or code.","title":"Goals Summary"},{"location":"/Goals.html#the-structure-of-the-m1cs-end-to-end-system","text":"The suggested structure of the M1CS segments control is described in the document overview in the first section.","title":"The structure of the M1CS end-to-end system"},{"location":"/Goals.html#demonstration-of-how-to-create-setups-that-map-to-lscs-commands","text":"A suggested approach for creating Setups for Assembly commands is presented here. This approach also shows how to go from an Assembly Setup to an SCMS segment command in the Assembly. Other approaches are possible, of course.","title":"Demonstration of how to create Setups that map to LSCS commands"},{"location":"/Goals.html#provide-examples-of-implementing-the-lscs-commands-not-all-commands-in-the-dictionary-are-provided-","text":"Ten example commands were implemented as part of the lscs-example. The others, once fully documented, can be implemented by following the pattern. The commands are implemented in the files in the lscsCommands project.","title":"Provide examples of implementing the LSCS commands (not all commands in the dictionary are provided)"},{"location":"/Goals.html#support-for-sending-a-command-to-one-or-all-segments-in-the-hcd","text":"All implemented commands support sending to 1 segment or ALL segments. A SegmentId type is available for addressing a single segment. The support for 1 or ALL segments is supported uniformly for all commands.\nThe HCD also supports sending and completing commands to 1 or ALL segments.\nSee here and processing in the HCD here.","title":"Support for sending a command to one or all segments in the HCD"},{"location":"/Goals.html#support-for-sending-commands-to-segment-using-jpl-protocol-and-communicate-with-the-m1cs-teams-simulator","text":"Allan has written a JVM-based simulator that obeys the JPL C-library protocol. It is possible to replace the JVM-based simulator with the C-based simulator in m1cs-lscs-sim and test, etc continue to work although the behavior is not the same. The C-based simulator returns immediately for all commands. See this page (this is a private repo and may give 404).","title":"* Support for sending commands to Segment using JPL protocol and communicate with the M1CS-team’s simulator"},{"location":"/Goals.html#demonstration-that-commands-to-all-segments-can-complete-when-all-segment-commands-complete","text":"This is one of the most important goals of the demonstration project. The actor SegComMonitor was created to handle the responses from 1 or All segments. The way SegComMonitor satisfies this goal is shown here. A test showing completion for 492 segments is shown in the same section.","title":"Demonstration that commands to all segments can complete when all segment commands complete"},{"location":"/Goals.html#demonstrate-that-individual-segment-commands-can-complete-asynchronously","text":"Handling asynchronous commands is an important feature. The JVM-based LSCS simulator demonstrates this by delaying a random amount of time for every segment command. This allows the higher-level software to demonstrate proper functionality with asynchronous commands. The SegComMonitor starts 1 or 492 commands without blocking and waits asynchrnously for their completion. All CSW framework messages are asynchronous so the command from the Assembly to the HCD is also asynchronous and the command to the Assembly can also be asynchronous. This is shown in the SegComMonitor reference as well as the test shown (other tests are present in the SegComMonitorTests class).","title":"Demonstrate that individual segment commands can complete asynchronously"},{"location":"/Goals.html#demonstrate-that-a-hcd-can-handle-overlapping-asynchronous-commands","text":"Similar to the previous point, the asynchronous nature of CSW makes overlapping commands operate naturally with no extra logic or special cases. The constraint on overlapping commands will come down to the functionality in the LSCS segment sofware itself. Overlapping asynchronous commands are shown in the SegComMonitor reference as well as the overlapping command test shown in that section.","title":"Demonstrate that a HCD can handle overlapping asynchronous commands"},{"location":"/Goals.html#demonstrate-that-the-csw-hcd-can-make-492-socket-connections-to-the-project-provided-lscs-simulator","text":"This is the requirement that started this demonstration project. Currently, creating 492 HCDs CSW is not possible, but that is not really needed, because the interface to the LSCS is simple and creating a socket connection turns out to be lightweight (forgetting the issue with macOS, of course). It might be reasonable to create the connections only when a command is sent. The ability to make 492 segments can be tested at a very low level. The SocketClientStreamTest shows creating 492 segments. See the simulator page.","title":"Demonstrate that the CSW HCD can make 492 socket connections to the project-provided LSCS simulator"},{"location":"/Goals.html#show-how-to-test-the-code-at-various-levels","text":"The demonstration project shows how to create CSW tests starting at the lowest level with tests involving more and more functionality following the TMT Testing Plan. See the testing page for a list of all tests. Also see the test directory under each of the projects: lscsCommands, lscsComps, lscsDeploy.","title":"Show how to test the code at various levels"},{"location":"/Goals.html#demonstrate-how-to-send-commands-to-the-lscs-assembly-from-esw-shell","text":"Examples showing the use of the lscsCommands JAR file and esw-shell is shown in the testing page: testing page.","title":"Demonstrate how to send commands to the LSCS Assembly from esw-shell"}]}