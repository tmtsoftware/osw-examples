<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="docs">
<meta name="generator" content="Paradox, paradox-material-theme=0.7.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="docs">
<link rel="shortcut icon" href="assets/images/favicon.png">
<title>LSCS Segments HCD Â· Lower Segment Control System Demonstration</title>
<link rel="stylesheet" href="assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="lib/prettify/prettify.css">
<script src="assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="assets/fonts/font-awesome.css">
<link rel="stylesheet" href="assets/fonts/material-icons.css">
<link rel="stylesheet" href="assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="index.html" title="Lower Segment Control System Demonstration" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Lower Segment Control System Demonstration
</span>
<span class="md-header-nav__topic">
LSCS Segments HCD
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="index.html" title="Lower Segment Control System Demonstration" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="index.html" title="Lower Segment Control System Demonstration">
Lower Segment Control System Demonstration
</a>
</label>
<ul>
  <li><a href="input-output.html" class="page">Setup Input/Output</a></li>
  <li><a href="LSCSAssembly.html" class="page">LSCS Segments Assembly</a></li>
  <li><a href="LSCSHcd.html" class="active page">LSCS Segments HCD</a></li>
  <li><a href="LSCSSimulator.html" class="page">LSCS Simulator and JPL Simulator</a></li>
  <li><a href="Deploy.html" class="page">Segments Assembly and HCD Deployment</a></li>
  <li><a href="TestingAndShell.html" class="page">Testing LSCS Code and Using esw-shell</a></li>
  <li><a href="Goals.html" class="page">Goals Summary</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="LSCSHcd.html#lscs-segments-hcd" class="header">LSCS Segments HCD</a>
  <ul>
    <li><a href="LSCSHcd.html#top-level-actor" class="header">Top Level Actor</a></li>
    <li><a href="LSCSHcd.html#initialization" class="header">Initialization</a></li>
    <li><a href="LSCSHcd.html#hcd-command-validation" class="header">HCD Command Validation</a></li>
    <li><a href="LSCSHcd.html#segments-hcd-command-execution" class="header">Segments HCD Command Execution</a></li>
    <li><a href="LSCSHcd.html#lscsdirectcommand-implementation" class="header">lscsDirectCommand Implementation</a></li>
    <li><a href="LSCSHcd.html#segment-monitor" class="header">Segment Monitor</a></li>
    <li><a href="LSCSHcd.html#segment-actor" class="header">Segment Actor</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.1.0*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="LSCSHcd.html#lscs-segments-hcd" class="header">LSCS Segments HCD</a>
  <ul>
    <li><a href="LSCSHcd.html#top-level-actor" class="header">Top Level Actor</a></li>
    <li><a href="LSCSHcd.html#initialization" class="header">Initialization</a></li>
    <li><a href="LSCSHcd.html#hcd-command-validation" class="header">HCD Command Validation</a></li>
    <li><a href="LSCSHcd.html#segments-hcd-command-execution" class="header">Segments HCD Command Execution</a></li>
    <li><a href="LSCSHcd.html#lscsdirectcommand-implementation" class="header">lscsDirectCommand Implementation</a></li>
    <li><a href="LSCSHcd.html#segment-monitor" class="header">Segment Monitor</a></li>
    <li><a href="LSCSHcd.html#segment-actor" class="header">Segment Actor</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#lscs-segments-hcd" name="lscs-segments-hcd" class="anchor"><span class="anchor-link"></span></a>LSCS Segments HCD</h1>
<p>The project includes a Segments HCD that processes segments commands. As discussed in the <a href="index.html">overview</a>, the Segments HCD receives HCD Setups from the Assembly (or other sources), validates them and then sends them off to one or more segments. It monitors each of the segments for a response, which is hopefully success, but may be an error. Once all the segments complete successfully or if any segment completes with an Error, the HCD command is completed and a response is passed back to the caller. There are no events of any kind produced by the HCD.</p>
<h2><a href="#top-level-actor" name="top-level-actor" class="anchor"><span class="anchor-link"></span></a>Top Level Actor</h2>
<p>The Top Level Actor for Segments HCD can be found in the <code>lscsComps</code> project in the file named <code>SegmentsHcdHandlers.scala</code>, which contains the majority of the HCD code. As with all CSW components, the TLA for Segments HCD implements handlers as needed. In this HCD, only <code>initialize</code>, <code>validateCommand</code>, and <code>onSubmit</code> handlers are implemented. Unlike the Assembly, the HCD does not use the <code>onLocationTrackingevent</code> handler.</p>
<h2><a href="#initialization" name="initialization" class="anchor"><span class="anchor-link"></span></a>Initialization</h2>
<p>Initialization in the Segments HCD does the important job of creating the Segments, which is discussed later. Here only the job of initializing the segments is done.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/osw-examples/tree/master/lscsComps/src/main/scala/m1cs/segments/hcd/SegmentsHcdHandlers.scala#L36-L55" target="_blank" title="Go to snippet source">source</a><code class="language-scala">// Set this during initialization to be a Segments instance
private var createdSegments: Segments = _

/**
 * The TLA initialize reads the number of segments from the reference.conf file.  This is convenient for
 * testing. It creates that number of segments in each sector.  At some point this could be removed and
 * replaced with MAX_SEGMENT_NUMBER.
 */
override def initialize(): Unit = {
  val segPath = &quot;m1cs.segments&quot;
  val maxSegments =
    if (ctx.system.settings.config.hasPath(segPath))
      ctx.system.settings.config.getInt(segPath)
    else SegmentId.MAX_SEGMENT_NUMBER
  val segmentRange = 1 to maxSegments //SegmentId.MAX_SEGMENT_NUMBER
  log.info(
    s&quot;Initializing Segments HCD with ${segmentRange.max} segments in each sector for a total of ${segmentRange.max * SegmentId.ALL_SECTORS.size} segments.&quot;
  )
  createdSegments = SegmentManager.createSegments(creator, segmentRange, log)
}</code></pre></dd>
</dl>
<p>Any state that is initialized in the <code>initialize</code> handler must be global to the TLA. In this case, there is a variable called <code>createdSegments</code> of type <code>Segments</code> that is set during initialize. The segments value is managed by the SegmentManager object, but it is essentially a Map of SegmentId values to SegmentActor references.<br/>The variable <code>createdSegments</code> is used by the onSubmit handler.</p>
<p>As shown, the code gets the <code>maxSegments</code> value from the reference.conf file and hands it to the SegmentManager to create segments. As mentioned before, the Segment Manager will create that number of segments in each sector. Therefore, the maximum value for maxSegments is MAX_SEGMENT_NUMBER and once one is happy with the simulator, the check can either be eliminated or set to 82 in the reference.conf file.</p>
<h2><a href="#hcd-command-validation" name="hcd-command-validation" class="anchor"><span class="anchor-link"></span></a>HCD Command Validation</h2>
<p>As in the Assembly, an <code>Observe</code> is rejected and the Setup is passed to another function for validation. The <code>validateCommand</code> handler is shown below.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/osw-examples/tree/master/lscsComps/src/main/scala/m1cs/segments/hcd/SegmentsHcdHandlers.scala#L74-L106" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/*
 * All Setup validation is performed here. Three checks are done for a lscsDirectCommand:
 * 1. is there a valid LSCS command
 * 2. is there a segmentId key (one or all)
 * 3. If one segment, is the segment available?
 * The HCD shutdown command is also accepted.  All others are rejected.
 */
private def handleValidation(runId: Id, setup: Setup): ValidateCommandResponse = {
  setup.commandName match {
    case HcdDirectCommand.lscsDirectCommand =&gt;
      if (!setup.exists(lscsCommandKey))
        Invalid(runId, CommandIssue.MissingKeyIssue(s&quot;Setup must include the ${lscsCommandKey.keyName} parameter.&quot;))

      if (!setup.exists(segmentIdKey))
        Invalid(runId, CommandIssue.MissingKeyIssue(s&quot;Setup must include the ${segmentIdKey.keyName} parameter.&quot;))

      // Verify that if one segment, that the segment is online in the list
      val segmentIdValue = setup(segmentIdKey).head
      if (segmentIdValue != ALL_SEGMENTS &amp;&amp; !createdSegments.segmentExists(SegmentId(segmentIdValue))) {
        Invalid(
          runId,
          CommandIssue.ParameterValueOutOfRangeIssue(s&quot;The segmentId: $segmentIdValue is not currently available.&quot;)
        )
      }
      else {
        Accepted(runId)
      }
    case HcdShutdown.shutdownCommand =&gt;
      Accepted(runId)
    case other =&gt;
      Invalid(runId, CommandIssue.UnsupportedCommandIssue(s&quot;HCD does not accept the command: $other&quot;))
  }
}</code></pre></dd>
</dl>
<p>The HCD can process two commands: lscsDirectCommand and shutdownCommand. For lscsDirectCommand <code>handleValidation</code> does three things:</p>
<ol>
  <li>Is the <code>lscsCommandKey</code> present? If not, return Invalid.</li>
  <li>Is a <code>segmentIdKey</code> included? If not, return Invalid.</li>
  <li>Finally, if the destination is a single segment, check to see if the destination segment is &ldquo;online&rdquo;. Since we can configure the number of segments to create, it&rsquo;s possible to send a command to a segment that does not exist. If this check fails, return Invalid.</li>
</ol>
<p>If these three things pass, the Setup is Accepted. There is probably more that could be done but that&rsquo;s it for now. We are assuming that the input/output library is used to constructing the Setups so no checks for required parameters are done.</p>
<p>The HCD also accepts the HcdShutdown.shutdownCommand. This command is always accepted.</p>
<p>If any other command is received by the HCD, it is rejected and Invalid is returned.</p>
<h2><a href="#segments-hcd-command-execution" name="segments-hcd-command-execution" class="anchor"><span class="anchor-link"></span></a>Segments HCD Command Execution</h2>
<p>Once validated, the <code>onSubmit</code> handler is called. Like the Assembly, the HCD rejects Observes and hands off execution to <code>handleSetup</code>. Checking for Observe again isn&rsquo;t needed since it is done in validation. HandleSetup is reproduced below. This is the crux of the HCD.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/osw-examples/tree/master/lscsComps/src/main/scala/m1cs/segments/hcd/SegmentsHcdHandlers.scala#L121-L166" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/**
 * Processes commands as Setups for the HCD.
 * @param runId command runId
 * @param setup the [[Setup]] to execute
 * @return [[SubmitResponse]] response from the command. All commands are started currently.
 */
private def handleSetup(runId: Id, setup: Setup): SubmitResponse = {
  setup.commandName match {
    case HcdDirectCommand.lscsDirectCommand =&gt;
      // We know all these params are present at this point
      val command         = setup(lscsCommandKey).head
      val commandName     = setup(lscsCommandNameKey).head
      val segmentKeyValue = setup(segmentIdKey).head
      // The sendList, at this point, is either one segment or all segments.  The same execution approach
      // is used regardless of one or all
      val sendList = if (segmentKeyValue == ALL_SEGMENTS) {
        createdSegments.getAllSegments
      }
      else {
        createdSegments.getSegment(segmentId = SegmentId(segmentKeyValue))
      }

      // Here a SegComMonitor is created to send and watch for completion of the command. The sendList is the
      // list of SegmentActors that will receive the command.  The function passed as the 5th argument will
      // be executed when all the segment commands complete either successfully or with an error.
      val mon1 = ctx.spawnAnonymous(
        hcd.SegComMonitor(
          commandName,
          command,
          sendList.segments,
          runId,
          (sr: SubmitResponse) =&gt; cswCtx.commandResponseManager.updateCommand(sr),
          log
        )
      )
      // Start the command and return Started to the Assembly
      mon1 ! SegComMonitor.Start
      Started(runId)
    case HcdShutdown.shutdownCommand =&gt;
      //This just sends shutdown to all the online segments
      createdSegments.shutdownAll()
      Completed(runId)
    case other =&gt;
      Error(runId, s&quot;This HCD does not handle this command: $other&quot;)
  }
}</code></pre></dd>
</dl>
<p>There are two commands, <code>lscsDirectCommand</code>, and <code>shutdownCommand</code>.</p>
<h2><a href="#lscsdirectcommand-implementation" name="lscsdirectcommand-implementation" class="anchor"><span class="anchor-link"></span></a>lscsDirectCommand Implementation</h2>
<p>The first thing that occurs is the command name, the segment destination, and the command String are extracted from the Setup. Then the segmentKeyValue, which is either ALL_SEGMENTS or a specific segment ID is tested for and used to access a list of segments for the command. It calls SegmentManager to return on or all.</p>
<p>Then a <code>SegComMonitor</code> actor is created, which takes the command String, the list of segments, the runId of the request, and a function to execute when all the segments have completed.<br/>The <code>SegComMonitor.Start</code> message is sent to the monitor, which causes the sending of the command to all the segments.</p>
<p>Just as a note in case it is not clear. These lscsDirectCommands executed by the HCD are totally asynchronous. As you can see from the code, once a monitor is started, the submit-handler returns <code>Started</code> indicating to the caller that a long- running command is started. The HCD is then available to accept and process another HCD/segment command, which starts its own SegComMonitor. The tests demonstrate that this works.</p>
<h2><a href="#segment-monitor" name="segment-monitor" class="anchor"><span class="anchor-link"></span></a>Segment Monitor</h2>
<p>Segment Monitor is the longest piece of code in the project. Segment Monitor is an actor implementing a two state finite state machine that has the job of executing a segment command and waiting for responses. The code is long but is included here.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/osw-examples/tree/master/lscsComps/src/main/scala/m1cs/segments/hcd/SegComMonitor.scala#L43-L155" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/**
 * These are the commands for the Command Sequence Monitor. The WrappedSegmentResponse is needed to receive
 * the SegmentActor.Response and transform it into a SegComMonitor.Command.
 * CommandTimeout is is issued and received if the Command Monitor times out before receiving all segment responses.
 */
sealed trait Command
final private case class WrappedSegmentResponse(response: SegmentActor.Response) extends Command
case object Start                                                                extends Command
final private case object CommandTimeout                                         extends Command

/**
 * This private class implements the Segment Command Monitor.
 * The class is an actor with a two state FSM. The monitor is created with a list of segment actors and a
 * segment command that is to be sent to each of the segment actors in the list. It waits for the Start message
 * in the `starting` state. Once Start is received, it sends to command sequentially to each segment actor and
 * waits for the responses in the `waiting` state.
 *
 * It determines completion by counting responses and also checking that the responses are Completed rather than Error.
 * Once the correct number of responses have been received, it executes the replyTo function, which is usually a
 * function to update the CSW CRM, which notifies the caller that the command is completed.
 *
 * There is one more feature.  A timeout can be provided that will allow the command to timeout and reply to the
 * caller with an Error.
 *
 * A new Segment Command Monitor is created for every command executed, after all the responses have been received or
 * the monitor is otherwise completed, the monitor returns Behaviors.stopped, which causes the actor to be ended.
 */
class SegMonitor private[SegComMonitor] (
    commandName: String,
    fullCommand: String,
    segments: List[ActorRef[SegmentActor.Command]],
    runId: Id,
    replyTo: SubmitResponse =&gt; Unit, // This is here so that handler can provide the CRM but tests can do something else
    log: Logger,
    segmentResponseMapper: ActorRef[SegmentActor.Response],
    timeout: FiniteDuration
) {
  def starting(): Behavior[Command] =
    Behaviors.receiveMessage {
      case Start =&gt;
        log.debug(s&quot;Sending $commandName to ${segments.size} segments.&quot;)
        segments.foreach(_ ! SegmentActor.Send(commandName, fullCommand, segmentResponseMapper))
        waiting(segments.size, responsesReceived = 0)
      case _ =&gt;
        Behaviors.unhandled
    }

  /**
   * The waiting state is entered once the command is sent to the segments. Every time a response from a segment
   * is received, the Behavior calls itself with updated state. This is not a recursive call in Akka.
   * @param totalSegments the number of expected responses
   * @param responsesReceived number of responses received so far
   * @return a typed Behavior
   */
  def waiting(totalSegments: Int, responsesReceived: Int): Behavior[Command] =
    Behaviors.withTimers { timers =&gt;
      Behaviors
        .receiveMessage[Command] {
          case wrapped: WrappedSegmentResponse =&gt;
            wrapped.response match {
              case SegmentActor.Started(commandName, commandId, segmentId) =&gt;
                timers.startSingleTimer(TIMEOUT_KEY, CommandTimeout, timeout)
                log.debug(s&quot;Started: $segmentId:$commandName:$commandId with $timeout timeout.&quot;)
                Behaviors.same
              case SegmentActor.Completed(commandName, commandId, segmentId) =&gt;
                val updatedResponsesReceived = responsesReceived + 1
                if (totalSegments == updatedResponsesReceived) {
                  log.info(
                    s&quot;$commandName completed successfully for **$updatedResponsesReceived** segments. Sending Completed($runId)&quot;
                  )
                  log.debug(s&quot;Cancelling Timeout Timer&quot;)
                  timers.cancel(TIMEOUT_KEY)
                  replyTo(Completed(runId))
                  Behaviors.stopped
                }
                else {
                  if (Math.floorMod(responsesReceived, 20) == 0)
                    log.debug(s&quot;Completed: $segmentId:$commandName:$commandId  Total completed: $responsesReceived&quot;)
                  waiting(totalSegments, updatedResponsesReceived)
                }
              case SegmentActor.Processing(commandName, commandId, segmentId) =&gt;
                log.debug(s&quot;Processing: $segmentId:$commandName:$commandId&quot;)
                Behaviors.same
              case SegmentActor.Error(commandName, commandId, segmentId, message) =&gt;
                val updatedResponsesReceived = responsesReceived + 1
                log.error(
                  s&quot;Error: $segmentId:$commandName:$commandId--STOPPING, $updatedResponsesReceived responses received.&quot;
                )
                // Cancel the timeout timer
                timers.cancel(TIMEOUT_KEY)
                replyTo(Error(runId, message))
                Behaviors.stopped
            }
          case Start =&gt;
            Behaviors.unhandled
          case CommandTimeout =&gt;
            replyTo(
              Error(
                runId,
                s&quot;A segment command timed out after receiving: $responsesReceived responses of expected: $totalSegments.&quot;
              )
            )
            Behaviors.stopped
          case other =&gt;
            log.error(s&quot;SegComMonitor received some other message.  Just FYI: $other&quot;)
            Behaviors.same
        }
        .receiveSignal { case (_, PostStop) =&gt;
          log.debug(s&quot;&gt;&gt;&gt;SegComMonitor for $runId STOPPED&lt;&lt;&lt;&quot;)
          Behaviors.same
        }
    }
}</code></pre></dd>
</dl>
<p><code>SegComMonior</code> is created in the <code>starting</code> state, awaiting the <code>start</code> message from the HCD TLA. When received, it sends the full segment command to each of the SegmentActors on the list passed into the monitor from the TLA (it will be 1 segment or a list of all segments). Once the commands are sent, it moves to the <code>waiting</code> state.</p>
<p>The state is called <code>waiting</code> because it is waiting for the responses from the SegmentActors. First note that waiting starts a timer so that if something goes wrong in a SegmentActor, after a timeout period, the CommandTimeout message will be sent to itself, which will cause an Error SubmitResponse to be returned to the runId through the <code>replyTo</code> function.</p>
<p>The monitor is written to assume the SegmentActor will return responses as described in the M1CS docs including Started, and Processing, and Error messages. The happy case is the SegmentActor.Completed message. All the monitor does is count happy responses until it receives the correct number, it then sends Completed to the runId through the replyTo function. </p>
<p>If a single Error is returned, the monitor stops immediately&ndash;if a single segment produces an error out of all segments, it means the command fails immediately, and an Error is returned to the client through the runId and replyTo function.</p>
<p>The important part for completion is the code around the SegmentActor.Completed message. Whenever a segment returns a positive response, the count is incremented and waiting is called again (which appears recursive, but actually isn&rsquo;t). Once all the responses are received, the Completed SubmitResponse is sent to the caller through the replyTo function. The Behavior of the monitor becomes <code>Behaviors.stopped</code>, which causes the monitor actor to stop.</p><div class="callout note "><div class="callout-title">Note</div>
<p>The SegComMonitor is written in the functional typed actor style. See <a href="https://doc.akka.io/docs/akka/current/typed/index.html">akka.io</a>.</p></div><div class="callout warning "><div class="callout-title">Warning</div>
<p>Neither simulator implements the protocol that includes: Processing and Started messages. We suggest they not be implemented and keep the low-level protocol simple.</p>
<p>The Segment Actor tries to implement some features of the protocol, but it has little effect on the monitor or the HCD and Assembly, there is very little reason to send Started if the command is longer than 1 second or Processing messages. They provide no useful information at this level and just introduce potential for errors. This might be useful for a command-line UI, but that isn&rsquo;t the application here. We suggest dropping this since it isn&rsquo;t part of the JPL library.</p></div>
<p><code>SegComMonitor</code> tests are a good way to see how testing works and how we validate the M1CS requirement to complete all segment commands and complete a CSW command.</p>
<p>The following test shows sending a command to 492 segments and waiting for completion. First the <code>SegmentManager</code> is used to create a full mirror configuration. This is what the HCD does during initialization The <code>tester</code> is a function that notifies the com1Response TestProbe when the command completes.</p>
<p>Then a <code>SegComMonitor</code> is created with a test command and the list of 492 segments. It is then started, which causes the command to be sent to all the segments. Then the test code waits for the Compleiton message. Once received as a precaution it waits to see if any other messages arrive, then shutsdown all the segment connections and quits.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/osw-examples/tree/master/lscsComps/src/test/scala/m1cs/segments/hcd/SegComMonitorTests.scala#L168-L192" target="_blank" title="Go to snippet source">source</a><code class="language-scala">test(&quot;492 segments - send 1 - external&quot;) {
  // Note: This test fails on Mac, server must be running on Linux due to open file issue?

  val range = 1 to SegmentId.MAX_SEGMENT_NUMBER
  // Create segments
  val segments      = SegmentManager.createSegments(testCreator, range, log)
  val segmentActors = segments.getAllSegments.segments
  segmentActors.size shouldBe 492

  val com1Response = TestProbe[SubmitResponse]()
  val tester       = makeTester(com1Response)

  val runId1 = Id()
  val mon    = testKit.spawn(hcd.SegComMonitor(cn1, cn1full, segmentActors, runId1, tester, log))
  mon ! SegComMonitor.Start

  // This verifies that both commands finished successfully
  com1Response.expectMessage(10.seconds, Completed(runId1))

  // Wait for final logs
  com1Response.expectNoMessage(100.milli)
  segments.shutdownAll()

  testKit.stop(mon, 5.seconds)
}</code></pre></dd>
</dl>
<p>The following code is similar but in this case, the test starts and executes two overlapping segment commands and waits for them both to asynchronously complete either successfully or with an error. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/osw-examples/tree/master/lscsComps/src/test/scala/m1cs/segments/hcd/SegComMonitorTests.scala#L196-L229" target="_blank" title="Go to snippet source">source</a><code class="language-scala">test(&quot;492 segments - overlap - external&quot;) {
  // Note: This test fails on Mac, server must be running on Linux due to open file issue?

  val range = 1 to SegmentId.MAX_SEGMENT_NUMBER
  // Create segments
  val segments      = SegmentManager.createSegments(testCreator, range, log)
  val segmentActors = segments.getAllSegments.segments
  segmentActors.size shouldBe 492

  val com1Response = TestProbe[SubmitResponse]()
  val tester       = makeTester(com1Response)

  val runId1 = Id()
  val mon1   = testKit.spawn(hcd.SegComMonitor(cn1, cn1full, segmentActors, runId1, tester, log))
  mon1 ! SegComMonitor.Start

  val runId2 = Id()
  val mon2   = testKit.spawn(hcd.SegComMonitor(cn2, cn2full, segmentActors, runId2, tester, log))
  mon2 ! SegComMonitor.Start

  // This verifies that both commands finished successfully
  val messages = com1Response.receiveMessages(2, 15.seconds)
  messages.size shouldBe 2
  val resultRunIds = Set(messages.head.runId, messages(1).runId)
  resultRunIds.contains(runId1) shouldBe true
  resultRunIds.contains(runId2) shouldBe true

  // Wait for final logs or shutdown
  com1Response.expectNoMessage(100.milli)
  segments.shutdownAll()

  testKit.stop(mon1, 5.seconds)
  testKit.stop(mon2, 5.seconds)
}</code></pre></dd>
</dl>
<p>At least with the JVM simulator, it is not known which command will complete first because of the randomized delays, so the test waits for 2 messages and then checks that they are the correct messages.</p>
<h2><a href="#segment-actor" name="segment-actor" class="anchor"><span class="anchor-link"></span></a>Segment Actor</h2>
<p>The Segments HCD creates a SegmentActor instance for each configured segment. The SegmentActor is a wrapper for the class called <code>SocketClientStream</code>, which is the low-level communication with the segment and which implements the JPL-library protocol. The code below is the interesting part of SegmentActor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/osw-examples/tree/master/lscsComps/src/main/scala/m1cs/segments/hcd/SegmentActor.scala#L14-L60" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object SegmentActor {

  // The following is temp hack for testing errors
  val ERROR_SEG_ID: Int                = 6
  val ERROR_COMMAND_NAME: String       = &quot;ERROR&quot;
  val FAKE_ERROR_MESSAGE: String       = &quot;Fake Error Message&quot;
  private implicit val timout: Timeout = Timeout(5.seconds)

  def apply(segmentId: SegmentId, log: Logger): Behavior[Command] = {
    Behaviors.setup[Command] { ctx =&gt;
      // Here we check to see if there is a property called simulatorHost
      val simulatorHost          = Properties.propOrElse(&quot;simulatorHost&quot;, &quot;localhost&quot;)
      val io: SocketClientStream = SocketClientStream(ctx, segmentId.toString, host = simulatorHost)
      handle(io, seqNo = 1, segmentId, log)
    }
  }

  private def getRandomDelay: FiniteDuration = FiniteDuration(Random.between(10, 1250), MILLISECONDS)

  private def handle(io: SocketClientStream, seqNo: Int, segmentId: SegmentId, log: Logger): Behavior[Command] =
    Behaviors.receive[Command] { (ctx, m) =&gt;
      import ctx.executionContext
      m match {
        case Send(commandName, args, replyTo) =&gt;
          ctx.self ! SendWithTime(commandName, args, getRandomDelay, replyTo)
          handle(io, seqNo, segmentId, log)

        case SendWithTime(commandName, _, delay, replyTo) =&gt;
          // The following fakes JPL Started until sim does it
          if (delay.toMillis &gt; 1000)
            replyTo ! Started(commandName, seqNo, segmentId)

          // Right now simulator just does random delays
          val simCommand = s&quot;DELAY ${delay.toMillis.toString}&quot;
          io.send(simCommand).onComplete {
            case Success(_) =&gt;
              // The value returned from the simulator is not used at this point.  That could change.
              // Message from simulator not used at this point
              if (commandName == ERROR_COMMAND_NAME)
                replyTo ! Error(commandName, seqNo, segmentId, FAKE_ERROR_MESSAGE)
              else
                replyTo ! Completed(commandName, seqNo, segmentId)
            case Failure(exception) =&gt;
              log.error(s&quot;Socket send failed: $exception&quot;, ex = exception)
              replyTo ! Error(commandName, seqNo, segmentId, &quot;Error received from simulator.&quot;)
          }
          handle(io, seqNo + 1, segmentId, log)</code></pre></dd>
</dl>
<p>First, when the SegmentActor is created in the <code>apply</code> def function. This is where the lower level <code>SocketClientStream</code> class is added and where the socket connection to the LSCS occurs.</p>
<p>The rest of the actor is a mix of trying to make the system behave like the documentation and interfacing to the current simulator.</p>
<p>For instance, the feature of sending a <code>Started</code> to the caller when the command takes greater than 1 second was added to ensure the system can handle that eventually. This is also true with the Processing message. </p><div class="callout note "><div class="callout-title">Note</div>
<p>But as it turns out, the higher level software and CSW can not do anything with these Started and Processing messages, so they should just be dropped.</p></div>
<p>SegmentActor has two messages related to sending a message to the segment. The first is Send, which is the operational case. It sends a command to the segment. The second is SendWithTime, which allows sending a time for the simulator delay to allow easier testing of things like multiple commands and overlapping commands.</p>
<p>At this level, all segment commands are implemented as a variable delay on the segment side of the socket. We send the command: DELAY MILLIS such as DELAY 1234 to the socket client. The delay is random returned by the <code>getRandomDelay</code> function. The delay is currently set to be between 10 and 1250 millis. </p>
<p>The important message of SegmentActor is the processing under <code>SendWithTime</code>. The code checks to see if the delay is greater than 1 second, if so it sends a <code>Started</code> message back to the caller. Then it uses the <code>send</code> method of the socket client to send the command to the segment socket. This is an asynchronous call using a Future. When the call completes, the SegmentActor sends a response to the caller, which is a <code>SegComMon</code> instance to be counted.</p>
<p>The ShutdownSegment command is also handled. When this occurs, the client is terminated, which closes the socket connection to the segment. These shutdown commands are present so that tests always work correctly. </p>
</div>
<div>
<a href="https://github.com/tmtsoftware/osw-examples/tree/master/docs/src/main/LSCSHcd.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.1.0*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="LSCSAssembly.html" title="LSCS Segments Assembly" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
LSCS Segments Assembly
</span>
</div>
</a>
<a href="LSCSSimulator.html" title="LSCS Simulator and JPL Simulator" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
LSCS Simulator and JPL Simulator
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="assets/javascripts/application.583bbe55.js"></script>
<script src="assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"."}})</script>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
