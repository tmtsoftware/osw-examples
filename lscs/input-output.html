<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Setup Input/Output · OSW Examples Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='paradox docs'/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/warnOldVersion.js"></script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/snippets.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>

<!--
<link rel="shortcut icon" href="../images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="../index.html" >
<span class="home-icon">⌂</span>OSW Examples Documentation
</a>
<div class="version-number">
0.1.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../commands/index.html" class="page">Commands Example Documentation</a></li>
  <li><a href="../lscs/index.html" class="page">Lower Segment Control System Demonstration</a>
  <ul>
    <li><a href="../lscs/input-output.html" class="active page">Setup Input/Output</a></li>
    <li><a href="../lscs/LSCSAssembly.html" class="page">LSCS Segments Assembly</a></li>
    <li><a href="../lscs/LSCSHcd.html" class="page">LSCS Segments HCD</a></li>
    <li><a href="../lscs/LSCSSimulator.html" class="page">LSCS Simulator and JPL Simulator</a></li>
    <li><a href="../lscs/Deploy.html" class="page">Segments Assembly and HCD Deployment</a></li>
    <li><a href="../lscs/TestingAndShell.html" class="page">Testing LSCS Code and Using esw-shell</a></li>
    <li><a href="../lscs/Goals.html" class="page">Goals and Addressed Issues Summary</a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title"><a href="../index.html">OSW Examples Documentation</a></div>

<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="../index.html" >
<span class="home-icon">⌂</span>OSW Examples Documentation
</a>
<div class="version-number">
0.1.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../commands/index.html" class="page">Commands Example Documentation</a></li>
  <li><a href="../lscs/index.html" class="page">Lower Segment Control System Demonstration</a>
  <ul>
    <li><a href="../lscs/input-output.html" class="active page">Setup Input/Output</a></li>
    <li><a href="../lscs/LSCSAssembly.html" class="page">LSCS Segments Assembly</a></li>
    <li><a href="../lscs/LSCSHcd.html" class="page">LSCS Segments HCD</a></li>
    <li><a href="../lscs/LSCSSimulator.html" class="page">LSCS Simulator and JPL Simulator</a></li>
    <li><a href="../lscs/Deploy.html" class="page">Segments Assembly and HCD Deployment</a></li>
    <li><a href="../lscs/TestingAndShell.html" class="page">Testing LSCS Code and Using esw-shell</a></li>
    <li><a href="../lscs/Goals.html" class="page">Goals and Addressed Issues Summary</a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<span id="version-warning"></span>

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="../index.html">OSW Examples Documentation</a></li>
  <li><a href="../lscs/index.html">Lower Segment Control System Demonstration</a></li>
  <li>Setup Input/Output</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#setup-input-output" name="setup-input-output" class="anchor"><span class="anchor-link"></span></a>Setup Input/Output</h1>
<p>This section describes how commands are encoded as Setups and how they are unpacked and transformed into commands that go to the individual segments.</p>
<h2><a href="#input-setup-description" name="input-setup-description" class="anchor"><span class="anchor-link"></span></a>Input: Setup Description</h2>
<p>The Segment Assembly receives CSW Setups, which may come from a variety of sources. In this project we demonstrate Setups from test code and using esw-shell (in a later section on testing). Input describes how Setups are created.</p>
<p>The strategy is to build a library of functions that make it relatively easy to construct Setups. The API is based on the previously referenced document. In this document each command is documented with a set of parameters that are required or optional. </p>
<p>The set of parameters for each command is generally different, although some share parameters. For instance, many commands include a selection of actuators. Each command also has a common parameter that indicates if the command should go to one specified segment or to all segments.</p>
<p>The creation of Setups is implemented in a separate project with only the code needed for the job so that a JAR file can be created that can be loaded into esw-shell. The <code>lscsCommands</code> JAR only depends on CSW libraries, which are included in esw-shell; therefore, scripts can be written using the library functions. </p>
<h2><a href="#implementing-commands" name="implementing-commands" class="anchor"><span class="anchor-link"></span></a>Implementing Commands</h2>
<p>A representative subset of the commands have been implemented. The plan was to do them all, but the documentation gets less reliable towards the end and is missing command examples for a few important commands.</p>
<p>There is a subproject called <code>lscsCommands</code>. This project contains all the code to create Assembly Setups and to extract and convert an Assembly Setup to a segment command string.</p>
<p>Under the package <code>m1cs.segments.segcommands</code> there is a file for each implemented command that is the name of the command. There are currently 10 commands implemented. Examples are: ACTUATOR, CFG_ACT_OFFLD, etc.</p>
<p>In each command file there is an object with the same name (i.e. ACTUATOR). An example is the Actuator command shown below, which includes all the features of the command implementation. Within the object is all the code to create a Setup and to extract a segment command. All commands are constructed the same way.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/osw-examples/tree/master/lscs-example/lscsCommands/src/main/scala/m1cs/segments/segcommands/ACTUATOR.scala#L11-L77" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object ACTUATOR {
  import Common.*

  // ACTUATOR command
  val COMMAND_NAME: CommandName = CommandName(&quot;ACTUATOR&quot;)

  object ActuatorModes extends Enumeration {
    type ActuatorMode = Value

    val OFF: Value       = Value(1, &quot;OFF&quot;)
    val TRACK: Value     = Value(2, &quot;TRACK&quot;)
    val SLEW: Value      = Value(3, &quot;SLEW&quot;)
    val CALIBRATE: Value = Value(4, &quot;CALIBRATE&quot;)
  }

  import ActuatorModes.*

  val actuatorChoices: Choices    = Choices.from(OFF.toString, TRACK.toString, SLEW.toString, CALIBRATE.toString)
  val actuatorModeKey: GChoiceKey = ChoiceKey.make(&quot;MODE&quot;, actuatorChoices)
  val targetKey: Key[Float]       = KeyType.FloatKey.make(&quot;TARGET&quot;)

  case class toActuator(prefix: Prefix, actId: Set[Int]) extends BaseCommand[toActuator](prefix, COMMAND_NAME) {

    setup = Common.addActuators(setup, actId)

    def withMode(mode: ActuatorMode): toActuator = {
      setup = setup.add(actuatorModeKey.set(Choice(mode.toString)))
      this
    }

    def withTarget(target: Double): toActuator = {
      setup = setup.add(targetKey.set(target.toFloat))
      this
    }

    // Make a copy -- do any checks here
    override def asSetup: Setup = {
      val mode   = setup.get(actuatorModeKey)
      val target = setup.get(targetKey)

      // Check that there is at least one
      require(mode.isDefined || target.isDefined, &quot;Actuator must have either a mode or target or both.&quot;)

      // Should require a segment set
      Setup(setup.source, setup.commandName, setup.maybeObsId, setup.paramSet)
    }
  }

  /**
   * Returns a formatted ACTUATOR command from a [Setup]
   *
   * @param setup Setup created with toActuator
   * @return String command ready to send
   */
  def toCommand(setup: Setup): String = {
    require(setup.commandName == COMMAND_NAME, s&quot;The provided Setup is not a: $COMMAND_NAME&quot;)
    val actId        = setup(actuatorIdKey)
    val modeExists   = setup.exists(actuatorModeKey)
    val targetExists = setup.exists(targetKey)
    require(targetExists || modeExists, &quot;ACTUATOR requires either a mode or a target or both.&quot;)
    val actIdVal = if (actId.size == 3) &quot;ALL&quot; else valuesToString(actId.values)
    val sb       = new StringBuilder(s&quot;${setup.commandName.name} ACT_ID=$actIdVal&quot;)
    if (modeExists) sb ++= s&quot;, MODE=${setup(actuatorModeKey).head.name}&quot;
    if (targetExists) sb ++= s&quot;, TARGET=${setup(targetKey).head}&quot;
    sb.result()
  }
}</code></pre></dd>
</dl>
<p>At the top of the object common code is imported. Following this is the name of the command, which is again, the name of the file. </p><div class="callout note "><div class="callout-title">Note</div>
<p>In this example, I decided that there would be a unique Setup for each command. So the CommandName is the name of the segment command. An alternative would be to have a single Setup type and include a parameter called CommandName. There are pros/cons of each approach. For the HCD, I selected the second approach.</p></div><div class="callout note "><div class="callout-title">Note</div>
<p>Each command is implemented as a case class with parameters that are the command&rsquo;s required parameters. There is a base class for all commands that includes a <code>Setup</code> and support for sending the command to one or all the segments with a segmentId key.</p></div>
<p>In this case, ACTUATOR includes the prefix of the sender, and a Set of integers indicating the actuators to influence. Examples are Set(1), Set(1,3). To indicate all actuators you can say Set(1,2,3) or ALL_ACTUATORS, which is an alias for Set(1,2,3). If the source is prefix: M1CS.client, the minimal Actuator command is:</p>
<pre class="prettyprint"><code class="language-scala">import csw.prefix.models.Prefix
import m1cs.segments.segcommands.Common.*
import m1cs.segments.segcommands.ACTUATOR.*
import m1cs.segments.segcommands.ACTUATOR.ActuatorModes.*

 
val prefix=Prefix(&quot;M1CS.client&quot;)
toActuator(prefix, Set(1))
</code></pre>
<p>This command is somewhat meaningless, because to be a correct ACTUATOR command it must have at least one of the optional parameters (see below).</p>
<h2><a href="#optional-parameters" name="optional-parameters" class="anchor"><span class="anchor-link"></span></a>Optional Parameters</h2>
<p>The value returned by toActuator is a <code>toActuator</code> instance. Optional values are added using &ldquo;with&rdquo; methods using a <code>fluid-style</code> API so options can be added as needed. For example to add the optional actuator mode and target, the following are all possible:</p>
<pre class="prettyprint"><code class="language-scala">toActuator(prefix, Set(1)).withMode(SLEW)

toActuator(prefix, Set(1)).withTarget(22.3)
</code></pre>
<p>This last example shows the optional parameters can be combined as needed:</p>
<pre class="prettyprint"><code class="language-scala">toActuator(prefix, ALL_ACTUATORS).withMode(SLEW).withTarget(22.3)
</code></pre>
<p>The case classes include <code>with</code> methods to add optional parameters as in:</p>
<pre class="prettyprint"><code class="language-scala">def withMode(mode: ActuatorMode): toActuator = {
  setup = setup.add(actuatorModeKey.set(Choice(mode.toString)))
  this
}

def withTarget(target: Double): toActuator = {
  setup = setup.add(targetKey.set(target.toFloat))
  this
}
</code></pre>
<p>Each method returns <code>this</code>, which is in this case an <code>toActuator</code> instance, allowing the fluid style. This is a reasonable way to support optional parameters in a typeable API.</p>
<h2><a href="#choice-parameters" name="choice-parameters" class="anchor"><span class="anchor-link"></span></a>Choice Parameters</h2>
<p>There are quite a few choice parameters. I&rsquo;ve implemented them as enumerations as shown below for <code>ActuatorMode</code>:</p>
<pre class="prettyprint"><code class="language-scala">import csw.params.core.models.{Choice, Choices}
import csw.params.core.generics.KeyType.ChoiceKey
import csw.params.core.generics.{GChoiceKey, Key, KeyType}

object ActuatorModes extends Enumeration {
    type ActuatorMode = Value

    val OFF: Value       = Value(1, &quot;OFF&quot;)
    val TRACK: Value     = Value(2, &quot;TRACK&quot;)
    val SLEW: Value      = Value(3, &quot;SLEW&quot;)
    val CALIBRATE: Value = Value(4, &quot;CALIBRATE&quot;)
  }

val actuatorChoices: Choices    = Choices.from(OFF.toString, TRACK.toString, SLEW.toString, CALIBRATE.toString)
val actuatorModeKey: GChoiceKey = ChoiceKey.make(&quot;MODE&quot;, actuatorChoices)
val targetKey: Key[Float]       = KeyType.FloatKey.make(&quot;TARGET&quot;)
</code></pre>
<p>The choice values must be imported as shown. This is also true when the API is used externally (i.e., not inside the command implementation). Each enumeration is supported with a <code>GChoiceKey</code> and the Choices are made up of the enumeration values as Strings.</p>
<p>The last line shows that there is a Float key for the TARGET value. Note that the API takes a Double, not a Float. This is because in Scala (and Java) you must add an <code>f</code> to make a value a Float, which is annoying. The conversion from a Double to a Float is done inside the code to make it a little more friendly to typing.</p>
<h2><a href="#conversion-to-setup" name="conversion-to-setup" class="anchor"><span class="anchor-link"></span></a>Conversion to Setup</h2>
<p>After creating a command instance like <code>toActutator</code>, it can then be converted to a Setup for submission to the Segment Assembly. Each command includes a method called <code>asSetup</code> that returns a Setup. This is the method that verifies that all the information has been entered that is required.</p>
<pre class="prettyprint"><code class="language-scala">override def asSetup: Setup = {
  val mode   = setup.get(actuatorModeKey)
  val target = setup.get(targetKey)

  // Check that there is at least one
  require(mode.isDefined || target.isDefined, &quot;Actuator must have either a mode or target or both.&quot;)

  // Should require a segment set
  Setup(setup.source, setup.commandName, setup.maybeObsId, setup.paramSet)
}
</code></pre>
<p>In the ACTUATOR command, when calling <code>asSetup</code> a check is done to verify that at least the mode or target is included. If neither of these parameters is provided, an exception is thrown. If it is good, a copy of the internal Setup is returned.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Many of the commands in the documentation have optional commands, but there is no information on what combinations are legal or which ones must really be provided as in the above ACTUATOR case. This can be fixed in the same way as the above was done once the documentation is improved.</p></div>
<p>In summary, to create a Setup to send to the Segment Assembly for the ACTUATOR command, the following is an example and the contents of the Setup:</p>
<pre class="prettyprint"><code class="language-scala">val setup = toActuator(prefix, ALL_ACTUATORS).withMode(SLEW).withTarget(22.3).asSetup
// setup: csw.params.commands.Setup = Setup(
//   source = Prefix(subsystem = M1CS, componentName = &quot;client&quot;),
//   commandName = CommandName(name = &quot;ACTUATOR&quot;),
//   maybeObsId = None,
//   paramSet = Set(
//     Parameter(
//       keyName = &quot;SegmentId&quot;,
//       keyType = StringKey,
//       items = ArraySeq(&quot;ALL&quot;),
//       units = none
//     ),
//     Parameter(
//       keyName = &quot;ACT_ID&quot;,
//       keyType = IntKey,
//       items = ArraySeq(1, 2, 3),
//       units = none
//     ),
//     Parameter(
//       keyName = &quot;MODE&quot;,
//       keyType = ChoiceKey,
//       items = ArraySeq(Choice(name = &quot;SLEW&quot;)),
//       units = none
//     ),
//     Parameter(
//       keyName = &quot;TARGET&quot;,
//       keyType = FloatKey,
//       items = ArraySeq(22.3F),
//       units = none
//     )
//   )
// )
</code></pre>
<h2><a href="#output-converting-a-setup-to-a-segment-command" name="output-converting-a-setup-to-a-segment-command" class="anchor"><span class="anchor-link"></span></a>Output: Converting a Setup to a Segment Command</h2>
<p>In the implementation approach mentioned on the overview page, the strategy is that the Assembly Segment receives the assembly Setup and converts it to an HCD Setup. The HCD Setup is a single command that has an argument that is the command that is sent to the segment as a String.</p>
<p>The output then is to extract the segment command from the Assembly Setup. Each command also implements a method called <code>toCommand</code>, which uses the parameters of the Setup to create a well-formed command. The following is the <code>toCommand</code> method for the ACTUATOR command.</p>
<pre class="prettyprint"><code class="language-scala">import csw.params.commands.{CommandName, Setup}

 /**
   * Returns a formatted ACTUATOR command from a [Setup]
   *
   * @param setup Setup created with toActuator
   * @return String command ready to send
   */
  def toCommand(setup: Setup): String = {
    require(setup.commandName == COMMAND_NAME, s&quot;The provided Setup is not a: $COMMAND_NAME&quot;)
    val actId        = setup(actuatorIdKey)
    val modeExists   = setup.exists(actuatorModeKey)
    val targetExists = setup.exists(targetKey)
    val actIdVal     = if (actId.size == 3) &quot;ALL&quot; else valuesToString(actId.values)
    val sb           = new StringBuilder(s&quot;${setup.commandName.name} ACT_ID=$actIdVal&quot;)
    if (modeExists) sb ++= s&quot;, MODE=${setup(actuatorModeKey).head.name}&quot;
    if (targetExists) sb ++= s&quot;, TARGET=${setup(targetKey).head}&quot;
    sb.result()
  }
</code></pre>
<p>To recap, a command includes required parameters and optional parameters. The above shows extracting the values for actuator, which is required. It creates a Boolean to check to see if actuator mode and/or target exists by checking for <code>actuatorModeKey</code> and <code>targetKey</code>. </p>
<p>Then a StringBuilder is created that creates a String for the command. First, the command is extracted using the Scala String interpolator syntax (${parameter}). The line starting with actIdVal checks to see whether there is a subset or all of the actuators. The valuesToString method formats a proper value for the command (as in (1,2)). Finally, if the mode and target exist, parameters are added to the String for each.</p>
<p>The example below is shows the output command that goes with the created Assembly Setup.</p>
<pre class="prettyprint"><code class="language-scala">toCommand(toActuator(prefix, ALL_ACTUATORS).withMode(TRACK).withTarget(22.34).asSetup)
// res4: String = &quot;ACTUATOR ACT_ID=ALL, MODE=TRACK, TARGET=22.34&quot;
</code></pre>
<h3><a href="#segment-destination" name="segment-destination" class="anchor"><span class="anchor-link"></span></a>Segment Destination</h3>
<p>Each command requires a segment location, but the location does not appear in the output command. The Setup contains a parameter for the segment destination. The following is the printed value of an ACTUATOR Setup for the example above.</p>
<pre class="prettyprint"><code class="language-scala">toActuator(prefix, ALL_ACTUATORS).withMode(TRACK).withTarget(22.34).asSetup
// res5: Setup = Setup(
//   source = Prefix(subsystem = M1CS, componentName = &quot;client&quot;),
//   commandName = CommandName(name = &quot;ACTUATOR&quot;),
//   maybeObsId = None,
//   paramSet = Set(
//     Parameter(
//       keyName = &quot;SegmentId&quot;,
//       keyType = StringKey,
//       items = ArraySeq(&quot;ALL&quot;),
//       units = none
//     ),
//     Parameter(
//       keyName = &quot;ACT_ID&quot;,
//       keyType = IntKey,
//       items = ArraySeq(1, 2, 3),
//       units = none
//     ),
//     Parameter(
//       keyName = &quot;MODE&quot;,
//       keyType = ChoiceKey,
//       items = ArraySeq(Choice(name = &quot;TRACK&quot;)),
//       units = none
//     ),
//     Parameter(
//       keyName = &quot;TARGET&quot;,
//       keyType = FloatKey,
//       items = ArraySeq(22.34F),
//       units = none
//     )
//   )
// )
</code></pre>
<p>There is an extra SegmentId parameter with the value ALL, indicating the command will be sent to all segments. This parameter is used by the HCD to do the right thing. The SegmentId parameter is handled within the command base class. By default, a command goes to all segments. </p>
<p>The base class also provides two methods called <code>toAll</code>, and <code>toSegment</code> to add a destination to any command as shown here:</p>
<pre class="prettyprint"><code class="language-scala">to = toActuator(prefix, Set(1, 3)).withMode(SLEW).toSegment(SegmentId(&quot;B22&quot;))
</code></pre>
<p>or</p>
<pre class="prettyprint"><code class="language-scala">to = toActuator(prefix, Set(1, 3)).withMode(SLEW).toAll
</code></pre>
<p>A SegmentId instance must be created to send to a specific segment. The SegmentId type verifies that the segment sector is A-F and segment number is 1-82. An exception is thrown if not true.</p>
<h2><a href="#testing-commands" name="testing-commands" class="anchor"><span class="anchor-link"></span></a>Testing Commands</h2>
<p>Tests exist for each command to verify that it is working properly. There is one file called SegmentCommandsTests in the lscsCommands test area. Each command has similar tests. The following shows the tests for Actuator.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/osw-examples/tree/master/lscs-example/lscsCommands/src/test/scala/m1cs/segments/segcommands/SegmentCommandsTests.scala#L29-L74" target="_blank" title="Go to snippet source">source</a><code class="language-scala">test(&quot;To From ACTUATOR&quot;) {
  import m1cs.segments.segcommands.ACTUATOR.*
  import m1cs.segments.segcommands.ACTUATOR.ActuatorModes.*

  var to = toActuator(prefix, Set(1, 3)).withMode(TRACK)
  // Verify segmentId is all by default
  to.asSetup(segmentIdKey).head shouldBe ALL_SEGMENTS

  // Verify override works
  to = toActuator(prefix, Set(1, 3)).withMode(TRACK).toSegment(SegmentId(&quot;A22&quot;))
  to.asSetup(segmentIdKey).head shouldBe &quot;A22&quot;

  // Only 2 actuators
  to = toActuator(prefix, Set(1, 3)).withMode(TRACK)
  ACTUATOR.toCommand(to.asSetup) shouldBe s&quot;${COMMAND_NAME.name} ACT_ID=(1,3), MODE=TRACK&quot;

  to = toActuator(prefix, Set(1, 3)).withTarget(22.34)
  ACTUATOR.toCommand(to.asSetup) shouldBe s&quot;${COMMAND_NAME.name} ACT_ID=(1,3), TARGET=22.34&quot;

  to = toActuator(prefix, Set(1, 3)).withMode(TRACK).withTarget(target = 22.34)
  ACTUATOR.toCommand(to.asSetup) shouldBe s&quot;${COMMAND_NAME.name} ACT_ID=(1,3), MODE=TRACK, TARGET=22.34&quot;

  // Verify All
  to = toActuator(prefix, ALL_ACTUATORS).withMode(TRACK).withTarget(22.34)
  ACTUATOR.toCommand(to.asSetup) shouldBe s&quot;${COMMAND_NAME.name} ACT_ID=ALL, MODE=TRACK, TARGET=22.34&quot;

  // Check for no optional
  assertThrows[IllegalArgumentException] {
    toActuator(prefix, Set(1, 2, 3)).asSetup
  }

  // Check for too big set
  assertThrows[IllegalArgumentException] {
    toActuator(prefix, Set(1, 2, 3, 4))
  }

  // Check for empty set
  assertThrows[IllegalArgumentException] {
    toActuator(prefix, Set())
  }

  // Check for out of range ID
  assertThrows[IllegalArgumentException] {
    toActuator(prefix, Set(1, 2, 4))
  }
}</code></pre></dd>
</dl>
<p>The tests create Setups with varied parameters and test that the output command is correct. Following are tests to verify that exceptions are thrown for bad conditions. For instance, note the test for the lack of an optional parameter.</p>
<pre class="prettyprint"><code class="language-scala"> // Check for no options
assertThrows[IllegalArgumentException] {
  toActuator(prefix, Set(1, 2, 3)).asSetup
}
</code></pre>
<p>This verifies that an exception is thrown if neither <code>withMode</code> nor <code>withTarget</code> is included.</p>
<h2><a href="#input-output-summary" name="input-output-summary" class="anchor"><span class="anchor-link"></span></a>Input/Output Summary</h2>
<p>Each command is created in the same way. A file is created in the <code>m1cs.segments.segcommands</code> package with the name of the command. A case class is created for the command with the required parameters. With methods are added for each optional parameter.</p>
<p>A <code>asSetup</code> method is included to check the Setup for consistency or constraints. A <code>toCommand</code> function is included to use the Setup parameters and output a segment command.</p>
<div class="source-github">
The source code for this page can be found <a href="https://github.com/tmtsoftware/osw-examples/tree/master/docs/target/mdoc/lscs/input-output.md">here</a>.
</div>

<div class="nav-next">
<p><strong>Next:</strong> <a href="../lscs/LSCSAssembly.html">LSCS Segments Assembly</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="../lscs/input-output.html#setup-input-output" class="header">Setup Input/Output</a>
  <ul>
    <li><a href="../lscs/input-output.html#input-setup-description" class="header">Input: Setup Description</a></li>
    <li><a href="../lscs/input-output.html#implementing-commands" class="header">Implementing Commands</a></li>
    <li><a href="../lscs/input-output.html#optional-parameters" class="header">Optional Parameters</a></li>
    <li><a href="../lscs/input-output.html#choice-parameters" class="header">Choice Parameters</a></li>
    <li><a href="../lscs/input-output.html#conversion-to-setup" class="header">Conversion to Setup</a></li>
    <li><a href="../lscs/input-output.html#output-converting-a-setup-to-a-segment-command" class="header">Output: Converting a Setup to a Segment Command</a></li>
    <li><a href="../lscs/input-output.html#testing-commands" class="header">Testing Commands</a></li>
    <li><a href="../lscs/input-output.html#input-output-summary" class="header">Input/Output Summary</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2022</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="../lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>
<script type="text/javascript">jQuery(function(jq){initOldVersionWarnings(jq, '0.1.0', '')});</script>


</html>
